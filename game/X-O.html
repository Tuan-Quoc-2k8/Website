<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>C·ªù Caro</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom right, #f0f8ff, #dcdcdc);
      text-align: center;
      margin: 0;
      padding: 0;
    }

    h1 {
      margin-top: 20px;
      color: #2c3e50;
    }

    .menu {
      margin: 20px auto;
      width: 320px;
      padding: 20px;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }

    label, select {
      display: block;
      margin-bottom: 10px;
      font-size: 16px;
      text-align: left;
    }

    #game {
      display: grid;
      gap: 4px;
      margin: 20px auto;
      width: max-content;
    }

    .cell {
      background-color: white;
      border: 2px solid #2980b9;
      font-size: 28px;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.3s;
    }

    .cell:hover {
      background-color: #ecf0f1;
    }

    .cell.X {
      color: #e74c3c;
    }

    .cell.O {
      color: #2ecc71;
    }

    .winner {
      background-color: gold !important;
    }

    #status {
      font-size: 20px;
      margin: 15px;
      color: #34495e;
    }

    button {
      padding: 10px 15px;
      font-size: 16px;
      margin-top: 10px;
      cursor: pointer;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
    }

    button:hover {
      background-color: #2980b9;
    }
  </style>
</head>
<body>

<h1>C·ªù Caro</h1>

<div class="menu">
  <label>Ch·∫ø ƒë·ªô ch∆°i:</label>
  <select id="gameMode">
    <option value="player">Ch∆°i v·ªõi ng∆∞·ªùi</option>
    <option value="easy">M√°y (D·ªÖ)</option>
    <option value="medium">M√°y (Trung b√¨nh)</option>
    <option value="hard">M√°y (Kh√≥)</option>
    <option value="super">M√°y (Si√™u kh√≥)</option>

  </select>

<select id="mapSize" onchange="updateGameModes()">
  <option value="3">3x3 (3 √¥ th·∫Øng)</option>
  <option value="7">7x7 (4 √¥ th·∫Øng)</option>
  <option value="10">10x10 (5 √¥ th·∫Øng)</option>
</select>


  <label>L∆∞·ª£t ƒëi ƒë·∫ßu:</label>
  <select id="firstTurn">
    <option value="X">X ƒëi tr∆∞·ªõc</option>
    <option value="O">O ƒëi tr∆∞·ªõc</option>
  </select>

  <label>Player 1 l√†:</label>
  <select id="player1Symbol">
    <option value="X">X</option>
    <option value="O">O</option>
  </select>

  <label>Player 2 / M√°y l√†:</label>
  <select id="player2Symbol">
    <option value="O">O</option>
    <option value="X">X</option>
  </select>

  <button onclick="startGame()">B·∫Øt ƒë·∫ßu ch∆°i</button>
</div>

<div id="status">Ch·ªçn c√†i ƒë·∫∑t v√† nh·∫•n b·∫Øt ƒë·∫ßu</div>
<div id="game"></div>
<button onclick="resetGame()">Ch∆°i l·∫°i</button>

<script>
  let board = [];
  let gridSize = 3;
  let winLength = 3;
  let currentPlayer = "X";
  let isGameActive = false;
  let mode = "player";
  let player1 = "X";
  let player2 = "O";
  const gameContainer = document.getElementById("game");
  const statusText = document.getElementById("status");

  function startGame() {
  const modeSelect = document.getElementById("gameMode").value;
  const mapSize = parseInt(document.getElementById("mapSize").value);
  const first = document.getElementById("firstTurn").value;
  const p1 = document.getElementById("player1Symbol").value;
  const p2 = document.getElementById("player2Symbol").value;

  mode = modeSelect;
  gridSize = mapSize;
  winLength = mapSize === 10 ? 5 : mapSize === 7 ? 4 : 3;  // ‚úÖ ƒêi·ªÅu ki·ªán th·∫Øng ch√≠nh x√°c
  currentPlayer = first;
  player1 = p1;
  player2 = p2;

  board = Array(gridSize * gridSize).fill("");
  isGameActive = true;

  renderBoard();
  statusText.textContent = `L∆∞·ª£t c·ªßa: ${currentPlayer}`;

  if (mode !== "player" && currentPlayer !== player1) {
    setTimeout(makeAIMove, 500);
  }
}

  function renderBoard() {
    gameContainer.innerHTML = "";
    gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, 60px)`;
    board.forEach((cell, index) => {
      const cellEl = document.createElement("div");
      cellEl.className = "cell";
      cellEl.textContent = cell;
      if (cell) cellEl.classList.add(cell);
      cellEl.onclick = () => handleClick(index);
      gameContainer.appendChild(cellEl);
    });
  }

  function handleClick(index) {
    if (!isGameActive || board[index] !== "") return;
    if (mode !== "player" && currentPlayer !== player1) return;

    board[index] = currentPlayer;
    renderBoard();

    if (checkWinner()) return;
    switchPlayer();

    if (mode !== "player" && currentPlayer === player2) {
      setTimeout(makeAIMove, 500);
    }
  }

  function switchPlayer() {
    currentPlayer = currentPlayer === "X" ? "O" : "X";
    statusText.textContent = `L∆∞·ª£t c·ªßa: ${currentPlayer}`;
  }

  function makeAIMove() {
  let emptyIndices = board
    .map((val, idx) => (val === "" ? idx : null))
    .filter((i) => i !== null);

  if (emptyIndices.length === 0 || !isGameActive) return;

  let choice;

  if (mode === "easy") {
    choice = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
  } else if (mode === "medium") {
    choice = mediumAI(emptyIndices);
  } else if (mode === "hard") {
    choice = hardAI(emptyIndices);
  } else if (mode === "super") {
    choice = bestMoveMinimax(currentPlayer); // üß† Minimax ·ªü ƒë√¢y
  }

  board[choice] = currentPlayer;
  renderBoard();

  if (checkWinner()) return;
  switchPlayer();
}

  function mediumAI(empty) {
    for (let i of empty) {
      board[i] = currentPlayer;
      if (checkWin(currentPlayer)) {
        board[i] = "";
        return i;
      }
      board[i] = "";
    }

    let opponent = currentPlayer === "X" ? "O" : "X";
    for (let i of empty) {
      board[i] = opponent;
      if (checkWin(opponent)) {
        board[i] = "";
        return i;
      }
      board[i] = "";
    }

    return empty[Math.floor(Math.random() * empty.length)];
  }

  function hardAI(empty) {
    const center = Math.floor(board.length / 2);
    if (board[center] === "") return center;
    return mediumAI(empty);
  }

  function checkWinner() {
    const winPositions = getWinningPositions(currentPlayer);
    if (winPositions.length > 0) {
      statusText.textContent = `Ng∆∞·ªùi ch∆°i ${currentPlayer} th·∫Øng!`;
      isGameActive = false;
      winPositions.forEach(i => {
        document.getElementsByClassName("cell")[i].classList.add("winner");
      });
      return true;
    }

    if (!board.includes("")) {
      statusText.textContent = "H√≤a!";
      isGameActive = false;
      return true;
    }

    return false;
  }

  function getWinningPositions(symbol) {
    const positions = [];

    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const index = row * gridSize + col;

        // Ngang
        if (col + winLength <= gridSize) {
          let line = [];
          for (let i = 0; i < winLength; i++) {
            if (board[index + i] === symbol) line.push(index + i);
          }
          if (line.length === winLength) return line;
        }

        // D·ªçc
        if (row + winLength <= gridSize) {
          let line = [];
          for (let i = 0; i < winLength; i++) {
            if (board[index + i * gridSize] === symbol) line.push(index + i * gridSize);
          }
          if (line.length === winLength) return line;
        }

        // Ch√©o \
        if (row + winLength <= gridSize && col + winLength <= gridSize) {
          let line = [];
          for (let i = 0; i < winLength; i++) {
            if (board[index + i * (gridSize + 1)] === symbol) line.push(index + i * (gridSize + 1));
          }
          if (line.length === winLength) return line;
        }

        // Ch√©o /
        if (row + winLength <= gridSize && col - winLength + 1 >= 0) {
          let line = [];
          for (let i = 0; i < winLength; i++) {
            if (board[index + i * (gridSize - 1)] === symbol) line.push(index + i * (gridSize - 1));
          }
          if (line.length === winLength) return line;
        }
      }
    }

    return [];
  }

  function checkWin(symbol) {
    return getWinningPositions(symbol).length > 0;
  }

  function resetGame() {
    startGame();
  }
  // t·ªëi ∆∞u m√°y kh√¥ng b·ªã ƒë·ª©ng h√¨nh tr∆∞·ªõc map l·ªõn
function bestMoveMinimax(player) {
  let bestScore = -Infinity;
  let move = -1;

  for (let i = 0; i < board.length; i++) {
    if (board[i] === "") {
      board[i] = player;
      let score = minimax(0, false, player, 4); // ‚ùó ƒê·∫∑t ƒë·ªô s√¢u t·ªëi ƒëa ·ªü ƒë√¢y
      board[i] = "";

      if (score > bestScore) {
        bestScore = score;
        move = i;
      }
    }
  }

  return move;
}


function minimax(depth, isMaximizing, aiPlayer) {
  const opponent = aiPlayer === "X" ? "O" : "X";

  if (checkWin(aiPlayer)) return 10 - depth;
  if (checkWin(opponent)) return depth - 10;
  if (!board.includes("")) return 0;

  let bestScore = isMaximizing ? -Infinity : Infinity;

  board.forEach((cell, index) => {
    if (cell === "") {
      board[index] = isMaximizing ? aiPlayer : opponent;
      let score = minimax(depth + 1, !isMaximizing, aiPlayer);
      board[index] = "";
      bestScore = isMaximizing
        ? Math.max(score, bestScore)
        : Math.min(score, bestScore);
    }
  });

  return bestScore;
}
function updateGameModes() {
  const mapSize = parseInt(document.getElementById("mapSize").value);
  const modeSelect = document.getElementById("gameMode");
  
  // L·∫•y t·∫•t c·∫£ c√°c option trong gameMode
  const options = modeSelect.options;

  for (let i = 0; i < options.length; i++) {
    if (options[i].value === "super") {
      options[i].disabled = (mapSize !== 3); // ‚ùó Ch·ªâ b·∫≠t n·∫øu mapSize === 3
    }
  }

  // N·∫øu ƒëang ch·ªçn "super" m√† mapSize kh√°c 3 => chuy·ªÉn sang "player"
  if (modeSelect.value === "super" && mapSize !== 3) {
    modeSelect.value = "player";
  }
}
window.onload = function () {
  updateGameModes();
};

</script>

</body>
</html>