<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Rush - Professional 3D Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff006e;
            --accent-color: #ffbe0b;
            --bg-dark: #0a0e27;
            --bg-medium: #1a1f3a;
            --bg-light: #2a2f4a;
            --text-color: #ffffff;
        }

        /* Theme: Neon Night */
        body[data-theme="neon"] {
            --primary-color: #00d4ff;
            --secondary-color: #ff006e;
            --accent-color: #ffbe0b;
            --bg-dark: #0a0e27;
            --bg-medium: #1a1f3a;
            --bg-light: #2a2f4a;
        }

        /* Theme: Cyber Racing */
        body[data-theme="cyber"] {
            --primary-color: #00ff9f;
            --secondary-color: #bd00ff;
            --accent-color: #00ffff;
            --bg-dark: #0d0221;
            --bg-medium: #1b0638;
            --bg-light: #2d0a52;
        }

        /* Theme: Classic Motorsport */
        body[data-theme="classic"] {
            --primary-color: #ff4d00;
            --secondary-color: #0066ff;
            --accent-color: #ffd700;
            --bg-dark: #1a1a1a;
            --bg-medium: #2d2d2d;
            --bg-light: #404040;
        }

        /* Theme: Street Racing */
        body[data-theme="street"] {
            --primary-color: #ff3333;
            --secondary-color: #ffcc00;
            --accent-color: #00ff00;
            --bg-dark: #0f0f0f;
            --bg-medium: #1f1f1f;
            --bg-light: #333333;
        }

        body {
            font-family: 'Rajdhani', 'Orbitron', 'Segoe UI', sans-serif;
            overflow: hidden;
            background: var(--bg-dark);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* UI Container */
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .ui-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: all;
            display: none;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
        }

        .ui-screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Racing-style decorative elements */
        .racing-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(90deg, transparent 48%, var(--primary-color) 48%, var(--primary-color) 52%, transparent 52%),
                linear-gradient(0deg, transparent 48%, var(--secondary-color) 48%, var(--secondary-color) 52%, transparent 52%);
            opacity: 0.03;
            pointer-events: none;
        }

        /* Intro Screen */
        .game-title {
            font-size: 6em;
            font-weight: 900;
            text-transform: uppercase;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 60px;
            text-shadow: 0 0 40px rgba(0, 212, 255, 0.5);
            letter-spacing: 0.1em;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .menu-btn {
            padding: 20px 80px;
            font-size: 1.6em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            border: 3px solid var(--primary-color);
            border-radius: 0;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.1em;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:hover {
            transform: translateX(10px);
            box-shadow: 0 0 30px var(--primary-color);
        }

        /* Map Selection */
        .map-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 30px;
            max-width: 1400px;
            padding: 30px;
            overflow-y: auto;
            max-height: 80vh;
        }

        .map-card {
            background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-light) 100%);
            border: 3px solid transparent;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .map-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid var(--primary-color);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .map-card:hover::before {
            opacity: 1;
        }

        .map-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.4);
        }

        .map-preview {
            width: 100%;
            height: 180px;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #000 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            border-bottom: 3px solid var(--primary-color);
        }

        .map-info {
            padding: 20px;
        }

        .map-name {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            color: var(--primary-color);
        }

        .star-rating {
            color: var(--accent-color);
            font-size: 1.4em;
            margin-bottom: 10px;
        }

        .map-description {
            color: #aaa;
            font-size: 1em;
            line-height: 1.4;
        }

        /* Garage Screen - Tabbed Layout */
        #garage-screen {
            justify-content: flex-start;
            padding: 30px;
        }

        .garage-container {
            display: flex;
            width: 100%;
            max-width: 1600px;
            gap: 30px;
            height: 85vh;
        }

        .car-viewer {
            flex: 2;
            background: var(--bg-medium);
            border: 3px solid var(--primary-color);
            position: relative;
            min-height: 600px;
        }

        .customization-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .car-stats-compact {
            background: var(--bg-medium);
            border: 3px solid var(--secondary-color);
            padding: 25px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--bg-light);
            padding: 12px;
            border-left: 4px solid var(--primary-color);
        }

        .stat-name {
            font-size: 0.85em;
            color: #aaa;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value-large {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-color);
        }

        .parts-tabs {
            background: var(--bg-medium);
            border: 3px solid var(--primary-color);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tab-headers {
            display: flex;
            border-bottom: 3px solid var(--primary-color);
        }

        .tab-header {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: var(--bg-light);
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s;
            border-right: 2px solid var(--bg-dark);
        }

        .tab-header:last-child {
            border-right: none;
        }

        .tab-header:hover {
            background: var(--bg-medium);
        }

        .tab-header.active {
            background: var(--primary-color);
            color: var(--bg-dark);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .part-option {
            background: var(--bg-light);
            padding: 18px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }

        .part-option:hover {
            background: var(--bg-medium);
            border-left-color: var(--primary-color);
        }

        .part-option.selected {
            border-left-color: var(--secondary-color);
            background: linear-gradient(90deg, var(--bg-medium), var(--bg-light));
        }

        .part-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
            color: var(--primary-color);
        }

        .part-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .stat-badge {
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 10px;
            font-size: 0.85em;
            border-radius: 3px;
        }

        .stat-badge.positive {
            color: #00ff00;
            border: 1px solid #00ff00;
        }

        .stat-badge.negative {
            color: #ff4444;
            border: 1px solid #ff4444;
        }

        /* Settings Screen */
        .settings-container {
            max-width: 700px;
            width: 100%;
            background: var(--bg-medium);
            padding: 40px;
            border: 3px solid var(--primary-color);
        }

        .setting-group {
            margin-bottom: 35px;
        }

        .setting-group h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-transform: uppercase;
            font-size: 1.4em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .theme-option {
            padding: 20px;
            background: var(--bg-light);
            border: 3px solid transparent;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .theme-option:hover {
            border-color: var(--primary-color);
        }

        .theme-option.active {
            border-color: var(--secondary-color);
            background: var(--primary-color);
            color: var(--bg-dark);
        }

        .setting-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px;
            background: var(--bg-light);
            margin-bottom: 12px;
        }

        .toggle-btn {
            width: 60px;
            height: 30px;
            background: #666;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
            border: 2px solid #444;
        }

        .toggle-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .toggle-btn::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #fff;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-btn.active::after {
            left: 32px;
        }

        select {
            padding: 12px;
            border: 2px solid var(--primary-color);
            background: var(--bg-dark);
            color: var(--text-color);
            font-size: 1em;
            font-weight: bold;
        }

        /* HUD - Racing Style */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: none;
        }

        #hud.active {
            display: block;
        }

        .hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .hud-speed {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            border: 3px solid var(--primary-color);
            border-left: 6px solid var(--secondary-color);
            padding: 15px 25px;
            min-width: 150px;
        }

        .speed-label {
            font-size: 0.9em;
            color: var(--primary-color);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .speed-value {
            font-size: 3.5em;
            font-weight: 900;
            line-height: 1;
            color: var(--text-color);
        }

        .speed-unit {
            font-size: 1.2em;
            color: #888;
        }

        /* Mini-Map */
        .mini-map {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--primary-color);
        }

        .mini-map canvas {
            width: 100%;
            height: 100%;
        }

        /* Position Display */
        .hud-position {
            position: absolute;
            top: 240px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-color);
            padding: 15px 25px;
            text-align: center;
        }

        .position-value {
            font-size: 3em;
            font-weight: 900;
            color: var(--accent-color);
        }

        .position-total {
            font-size: 1.2em;
            color: #888;
        }

        /* Lap Counter */
        .hud-lap {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--primary-color);
            padding: 15px 40px;
            font-size: 1.5em;
            font-weight: bold;
            text-transform: uppercase;
        }

        /* Skill Feedback */
        .skill-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: 900;
            padding: 25px 50px;
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid;
            display: none;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            animation: feedbackPop 2s;
        }
        
        /* Race Countdown */
        .countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10em;
            font-weight: 900;
            color: var(--primary-color);
            text-shadow: 0 0 50px var(--primary-color), 0 0 100px var(--secondary-color);
            display: none;
            pointer-events: none;
            z-index: 2000;
            animation: countdownPulse 1s ease-out;
        }
        
        .countdown-display.go {
            color: var(--accent-color);
            text-shadow: 0 0 50px var(--accent-color);
        }
        
        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @keyframes feedbackPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* Back Button */
        .back-btn {
            position: fixed;
            top: 30px;
            left: 30px;
            padding: 15px 35px;
            background: var(--bg-medium);
            border: 3px solid var(--primary-color);
            color: var(--text-color);
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .back-btn:hover {
            background: var(--primary-color);
            color: var(--bg-dark);
            transform: translateX(-5px);
        }

        h2 {
            margin-bottom: 40px;
            font-size: 2.5em;
            text-transform: uppercase;
            color: var(--primary-color);
            letter-spacing: 0.1em;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 15px;
        }
    </style>
</head>
<body data-theme="neon">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-container">
        <!-- Intro Screen -->
        <div id="intro-screen" class="ui-screen active">
            <div class="racing-lines"></div>
            <h1 class="game-title" data-i18n="gameTitle">CIRCUIT RUSH</h1>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="showMapSelection()">
                    <span data-i18n="play">‚ñ∂ RACE</span>
                </button>
                <button class="menu-btn" onclick="showGarage()">
                    <span data-i18n="carCustomization">üîß GARAGE</span>
                </button>
                <button class="menu-btn" onclick="showSettings()">
                    <span data-i18n="settings">‚öô SETTINGS</span>
                </button>
            </div>
        </div>

        <!-- Map Selection Screen -->
        <div id="map-select-screen" class="ui-screen">
            <button class="back-btn" onclick="showIntro()">‚Üê <span data-i18n="back">BACK</span></button>
            <h2 data-i18n="selectMap">SELECT CIRCUIT</h2>
            <div id="map-grid" class="map-grid"></div>
        </div>

        <!-- Garage Screen -->
        <div id="garage-screen" class="ui-screen">
            <button class="back-btn" onclick="showIntro()">‚Üê <span data-i18n="back">BACK</span></button>
            <div class="garage-container">
                <div class="car-viewer" id="garage-viewer"></div>
                <div class="customization-panel">
                    <div class="car-stats-compact">
                        <h3 style="color: var(--secondary-color); margin-bottom: 15px; text-transform: uppercase;">PERFORMANCE</h3>
                        <div class="stats-grid" id="stats-grid"></div>
                    </div>
                    <div class="parts-tabs">
                        <div class="tab-headers" id="tab-headers"></div>
                        <div id="tab-contents"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="ui-screen">
            <button class="back-btn" onclick="showIntro()">‚Üê <span data-i18n="back">BACK</span></button>
            <div class="settings-container">
                <h2 data-i18n="settings">SETTINGS</h2>
                
                <div class="setting-group">
                    <h3>UI THEME</h3>
                    <div class="theme-grid">
                        <div class="theme-option active" data-theme="neon" onclick="changeTheme('neon')">
                            NEON NIGHT
                        </div>
                        <div class="theme-option" data-theme="cyber" onclick="changeTheme('cyber')">
                            CYBER RACING
                        </div>
                        <div class="theme-option" data-theme="classic" onclick="changeTheme('classic')">
                            CLASSIC MOTORSPORT
                        </div>
                        <div class="theme-option" data-theme="street" onclick="changeTheme('street')">
                            STREET RACING
                        </div>
                    </div>
                </div>

                <div class="setting-group">
                    <h3 data-i18n="language">LANGUAGE</h3>
                    <div class="setting-option">
                        <span data-i18n="selectLanguage">Select Language</span>
                        <select id="language-select" onchange="changeLanguage(this.value)">
                            <option value="en">English</option>
                            <option value="vi">Ti·∫øng Vi·ªát</option>
                            <option value="jp">Êó•Êú¨Ë™û</option>
                        </select>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3 data-i18n="audio">AUDIO</h3>
                    <div class="setting-option">
                        <span data-i18n="backgroundMusic">Background Music</span>
                        <div class="toggle-btn" id="music-toggle" onclick="toggleMusic()"></div>
                    </div>
                    <div class="setting-option">
                        <span data-i18n="engineSound">Engine Sound</span>
                        <div class="toggle-btn active" id="sound-toggle" onclick="toggleSound()"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div class="hud-top-left">
                <div class="hud-speed">
                    <div class="speed-label" data-i18n="speed">SPEED</div>
                    <div>
                        <span class="speed-value" id="speed-display">0</span>
                        <span class="speed-unit">KM/H</span>
                    </div>
                </div>
            </div>

            <div class="mini-map">
                <canvas id="minimap-canvas" width="200" height="200"></canvas>
            </div>

            <div class="hud-position">
                <div class="position-value" id="position-display">1</div>
                <div class="position-total" id="position-total">/4</div>
            </div>

            <div class="hud-lap">
                <span data-i18n="lap">LAP</span> <span id="lap-display">1/3</span>
            </div>
        </div>

        <div class="skill-feedback" id="skill-feedback"></div>
        
        <div class="countdown-display" id="countdown-display">3</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ====================================================
        // INTERNATIONALIZATION
        // ====================================================
        const i18n = {
            en: {
                gameTitle: "CIRCUIT RUSH",
                play: "‚ñ∂ RACE",
                carCustomization: "üîß GARAGE",
                settings: "‚öô SETTINGS",
                back: "BACK",
                selectMap: "SELECT CIRCUIT",
                language: "LANGUAGE",
                selectLanguage: "Select Language",
                audio: "AUDIO",
                backgroundMusic: "Background Music",
                engineSound: "Engine Sound",
                speed: "SPEED",
                lap: "LAP",
                engine: "ENGINE",
                wheels: "WHEELS",
                spoiler: "SPOILER",
                exhaust: "EXHAUST",
                bodyKit: "BODY",
                maxSpeed: "Max Speed",
                acceleration: "Acceleration",
                braking: "Braking",
                handling: "Handling",
                grip: "Grip",
                driftControl: "Drift",
                stability: "Stability",
                weight: "Weight"
            },
            vi: {
                gameTitle: "CIRCUIT RUSH",
                play: "‚ñ∂ ƒêUA XE",
                carCustomization: "üîß GARAGE",
                settings: "‚öô C√ÄI ƒê·∫∂T",
                back: "TR·ªû L·∫†I",
                selectMap: "CH·ªåN ƒê∆Ø·ªúNG ƒêUA",
                language: "NG√îN NG·ªÆ",
                selectLanguage: "Ch·ªçn Ng√¥n Ng·ªØ",
                audio: "√ÇM THANH",
                backgroundMusic: "Nh·∫°c N·ªÅn",
                engineSound: "Ti·∫øng ƒê·ªông C∆°",
                speed: "T·ªêC ƒê·ªò",
                lap: "V√íNG",
                engine: "ƒê·ªòNG C∆†",
                wheels: "B√ÅNH XE",
                spoiler: "C√ÅNH GI√ì",
                exhaust: "·ªêNG X·∫¢",
                bodyKit: "BODY",
                maxSpeed: "T·ªëc ƒê·ªô T·ªëi ƒêa",
                acceleration: "TƒÉng T·ªëc",
                braking: "Phanh",
                handling: "X·ª≠ L√Ω",
                grip: "ƒê·ªô B√°m",
                driftControl: "Drift",
                stability: "·ªîn ƒê·ªãnh",
                weight: "Tr·ªçng L∆∞·ª£ng"
            },
            jp: {
                gameTitle: "CIRCUIT RUSH",
                play: "‚ñ∂ „É¨„Éº„Çπ",
                carCustomization: "üîß „Ç¨„É¨„Éº„Ç∏",
                settings: "‚öô Ë®≠ÂÆö",
                back: "Êàª„Çã",
                selectMap: "„Çµ„Éº„Ç≠„ÉÉ„ÉàÈÅ∏Êäû",
                language: "Ë®ÄË™û",
                selectLanguage: "Ë®ÄË™û„ÇíÈÅ∏Êäû",
                audio: "„Ç™„Éº„Éá„Ç£„Ç™",
                backgroundMusic: "BGM",
                engineSound: "„Ç®„É≥„Ç∏„É≥Èü≥",
                speed: "ÈÄüÂ∫¶",
                lap: "„É©„ÉÉ„Éó",
                engine: "„Ç®„É≥„Ç∏„É≥",
                wheels: "„Çø„Ç§„É§",
                spoiler: "„Ç¶„Ç§„É≥„Ç∞",
                exhaust: "„Éû„Éï„É©„Éº",
                bodyKit: "„Éú„Éá„Ç£",
                maxSpeed: "ÊúÄÈ´òÈÄüÂ∫¶",
                acceleration: "Âä†ÈÄü",
                braking: "„Éñ„É¨„Éº„Ç≠",
                handling: "„Éè„É≥„Éâ„É™„É≥„Ç∞",
                grip: "„Ç∞„É™„ÉÉ„Éó",
                driftControl: "„Éâ„É™„Éï„Éà",
                stability: "ÂÆâÂÆöÊÄß",
                weight: "ÈáçÈáè"
            }
        };

        let currentLanguage = 'en';

        function changeLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (i18n[lang] && i18n[lang][key]) {
                    el.textContent = i18n[lang][key];
                }
            });
            localStorage.setItem('language', lang);
        }

        // ====================================================
        // THEME SYSTEM
        // ====================================================
        function changeTheme(theme) {
            document.body.setAttribute('data-theme', theme);
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.remove('active');
            });
            document.querySelector(`[data-theme="${theme}"]`).classList.add('active');
            localStorage.setItem('theme', theme);
        }

        // ====================================================
        // GAME STATE
        // ====================================================
        const GameState = {
            INTRO: 'intro',
            MAP_SELECT: 'map_select',
            GARAGE: 'garage',
            SETTINGS: 'settings',
            RACING: 'racing'
        };

        let currentState = GameState.INTRO;

        function setState(state) {
            currentState = state;
            document.querySelectorAll('.ui-screen').forEach(screen => {
                screen.classList.remove('active');
            });

            const hud = document.getElementById('hud');
            hud.classList.remove('active');

            switch(state) {
                case GameState.INTRO:
                    document.getElementById('intro-screen').classList.add('active');
                    break;
                case GameState.MAP_SELECT:
                    document.getElementById('map-select-screen').classList.add('active');
                    break;
                case GameState.GARAGE:
                    document.getElementById('garage-screen').classList.add('active');
                    initGarage();
                    break;
                case GameState.SETTINGS:
                    document.getElementById('settings-screen').classList.add('active');
                    break;
                case GameState.RACING:
                    hud.classList.add('active');
                    break;
            }
        }

        function showIntro() { setState(GameState.INTRO); }
        function showMapSelection() { setState(GameState.MAP_SELECT); renderMapSelection(); }
        function showGarage() { setState(GameState.GARAGE); }
        function showSettings() { setState(GameState.SETTINGS); }

        // ====================================================
        // CAR PARTS SYSTEM
        // ====================================================
        const availableParts = {
            engine: [
                { id: 'engine_stock', name: 'Stock Engine', stats: { maxSpeed: 0, acceleration: 0, weight: 0 } },
                { id: 'engine_sport', name: 'Sport Engine', stats: { maxSpeed: 15, acceleration: 20, weight: 5 } },
                { id: 'engine_race', name: 'Race Engine', stats: { maxSpeed: 30, acceleration: 35, weight: 10 } },
                { id: 'engine_turbo', name: 'Turbo Engine', stats: { maxSpeed: 50, acceleration: 45, weight: 15, stability: -5 } }
            ],
            wheels: [
                { id: 'wheels_stock', name: 'Stock Wheels', stats: { grip: 0, handling: 0 } },
                { id: 'wheels_sport', name: 'Sport Wheels', stats: { grip: 15, handling: 10, weight: 2 } },
                { id: 'wheels_racing', name: 'Racing Slicks', stats: { grip: 30, handling: 20, weight: 5, driftControl: -10 } },
                { id: 'wheels_drift', name: 'Drift Wheels', stats: { grip: 10, driftControl: 35, handling: 5 } }
            ],
            spoiler: [
                { id: 'spoiler_none', name: 'No Spoiler', stats: { stability: 0 } },
                { id: 'spoiler_small', name: 'Small Spoiler', stats: { stability: 15, maxSpeed: -2 } },
                { id: 'spoiler_large', name: 'Large Spoiler', stats: { stability: 30, maxSpeed: -5, handling: 10 } },
                { id: 'spoiler_racing', name: 'Racing Wing', stats: { stability: 45, maxSpeed: -8, handling: 20, weight: 5 } }
            ],
            exhaust: [
                { id: 'exhaust_stock', name: 'Stock Exhaust', stats: { acceleration: 0 } },
                { id: 'exhaust_sport', name: 'Sport Exhaust', stats: { acceleration: 10, maxSpeed: 5 } },
                { id: 'exhaust_racing', name: 'Racing Exhaust', stats: { acceleration: 20, maxSpeed: 10, weight: -2 } }
            ],
            bodyKit: [
                { id: 'body_stock', name: 'Stock Body', stats: {} },
                { id: 'body_aero', name: 'Aero Kit', stats: { maxSpeed: 8, stability: 10, weight: 8 } },
                { id: 'body_lightweight', name: 'Lightweight Kit', stats: { acceleration: 15, weight: -20, stability: -5 } }
            ]
        };

        // ====================================================
        // CAR CONFIGURATION
        // ====================================================
        class CarConfiguration {
            constructor() {
                this.baseStats = {
                    maxSpeed: 100,
                    acceleration: 50,
                    braking: 50,
                    handling: 50,
                    grip: 50,
                    driftControl: 50,
                    stability: 50,
                    weight: 100
                };

                this.installedParts = {
                    engine: 'engine_stock',
                    wheels: 'wheels_stock',
                    spoiler: 'spoiler_none',
                    exhaust: 'exhaust_stock',
                    bodyKit: 'body_stock'
                };

                this.loadConfiguration();
            }

            installPart(partType, partId) {
                this.installedParts[partType] = partId;
                this.saveConfiguration();
            }

            getPartById(partType, partId) {
                return availableParts[partType].find(p => p.id === partId);
            }

            calculateFinalStats() {
                const stats = { ...this.baseStats };

                for (const partType in this.installedParts) {
                    const partId = this.installedParts[partType];
                    const part = this.getPartById(partType, partId);
                    
                    if (part && part.stats) {
                        for (const stat in part.stats) {
                            stats[stat] = (stats[stat] || 0) + part.stats[stat];
                        }
                    }
                }

                return stats;
            }

            saveConfiguration() {
                localStorage.setItem('carConfiguration', JSON.stringify(this.installedParts));
            }

            loadConfiguration() {
                const saved = localStorage.getItem('carConfiguration');
                if (saved) {
                    this.installedParts = JSON.parse(saved);
                }
            }
        }

        const carConfig = new CarConfiguration();

        // ====================================================
        // THREE.JS SETUP
        // ====================================================
        let scene, camera, renderer;
        let garageScene, garageCamera, garageRenderer;
        let playerCar, track;
        let garageCarMesh;
        let aiCars = [];
        let barriers = [];

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 150, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            if (garageCamera && garageRenderer) {
                const garageViewer = document.getElementById('garage-viewer');
                garageCamera.aspect = garageViewer.clientWidth / garageViewer.clientHeight;
                garageCamera.updateProjectionMatrix();
                garageRenderer.setSize(garageViewer.clientWidth, garageViewer.clientHeight);
            }
        }

        // ====================================================
        // FIX #1: PREMIUM SUPERCAR MODEL (REALISTIC DESIGN)
        // ====================================================
        function createSupercar(color = 0xff0000) {
            const carGroup = new THREE.Group();

            // RESEARCH-BASED PROPORTIONS
            // Real supercars: Lamborghini Aventador, Ferrari F8, McLaren 720S
            // - Length: ~4.5m, Width: ~2m, Height: ~1.1m
            // - Wheel diameter: ~0.7m, Width: ~0.3m
            // - Ground clearance: ~0.1m

            // === MAIN BODY - LOW AND WIDE ===
            const bodyLength = 5.2;
            const bodyWidth = 2.6;
            const bodyHeight = 0.55;
            
            const bodyGeometry = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyLength);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color, 
                metalness: 0.95, 
                roughness: 0.02,
                envMapIntensity: 2.0
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.45;
            body.castShadow = true;
            body.receiveShadow = true;
            carGroup.add(body);

            // === LOWER CHASSIS - GROUND EFFECT ===
            const chassisGeometry = new THREE.BoxGeometry(bodyWidth * 0.92, 0.25, bodyLength * 0.95);
            const chassis = new THREE.Mesh(chassisGeometry, bodyMaterial);
            chassis.position.y = 0.20;
            chassis.castShadow = true;
            carGroup.add(chassis);

            // === CABIN - SLEEK COCKPIT ===
            const cabinGeometry = new THREE.BoxGeometry(bodyWidth * 0.72, 0.65, bodyLength * 0.42);
            const cabinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a, 
                metalness: 0.9, 
                roughness: 0.12,
                transparent: true,
                opacity: 0.35
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 0.95, -0.3);
            cabin.castShadow = true;
            carGroup.add(cabin);
            
            // === WINDSHIELD - ANGLED ===
            const windshieldGeometry = new THREE.BoxGeometry(bodyWidth * 0.68, 0.50, 0.1);
            const windshield = new THREE.Mesh(windshieldGeometry, cabinMaterial);
            windshield.position.set(0, 0.92, 0.7);
            windshield.rotation.x = -0.3;
            carGroup.add(windshield);

            // === NOSE - SHARP FRONT ===
            const noseGeometry = new THREE.BoxGeometry(bodyWidth * 0.85, 0.32, 1.2);
            const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
            nose.position.set(0, 0.35, bodyLength * 0.48);
            nose.castShadow = true;
            carGroup.add(nose);
            
            // === FRONT LIP SPOILER ===
            const lipGeometry = new THREE.BoxGeometry(bodyWidth * 0.95, 0.08, 0.5);
            const lipMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a,
                metalness: 0.85,
                roughness: 0.15
            });
            const frontLip = new THREE.Mesh(lipGeometry, lipMaterial);
            frontLip.position.set(0, 0.14, bodyLength * 0.52);
            frontLip.castShadow = true;
            carGroup.add(frontLip);

            // === REAR DIFFUSER - AGGRESSIVE ===
            const diffuserGeometry = new THREE.BoxGeometry(bodyWidth * 0.90, 0.45, 1.0);
            const diffuser = new THREE.Mesh(diffuserGeometry, new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a,
                metalness: 0.75,
                roughness: 0.25
            }));
            diffuser.position.set(0, 0.25, -bodyLength * 0.48);
            diffuser.castShadow = true;
            carGroup.add(diffuser);

            // === SIDE SKIRTS ===
            [-1.35, 1.35].forEach(side => {
                const skirtGeometry = new THREE.BoxGeometry(0.18, 0.22, bodyLength * 0.75);
                const skirt = new THREE.Mesh(skirtGeometry, lipMaterial);
                skirt.position.set(side, 0.25, 0);
                skirt.castShadow = true;
                carGroup.add(skirt);
            });
            
            // === SIDE AIR INTAKES ===
            [-1.4, 1.4].forEach(side => {
                const intakeGeometry = new THREE.BoxGeometry(0.35, 0.25, 1.2);
                const intakeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    metalness: 0.6,
                    roughness: 0.5
                });
                const intake = new THREE.Mesh(intakeGeometry, intakeMaterial);
                intake.position.set(side, 0.55, -0.8);
                carGroup.add(intake);
            });

            // === WHEELS - LARGE PERFORMANCE WHEELS ===
            const wheelDiameter = 0.58;
            const wheelWidth = 0.45;
            const wheelGeometry = new THREE.CylinderGeometry(wheelDiameter, wheelDiameter, wheelWidth, 24);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a, 
                metalness: 0.5, 
                roughness: 0.6 
            });
            const rimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xb0b0b0, 
                metalness: 0.95, 
                roughness: 0.05 
            });

            const wheelPositions = [
                { x: -1.50, y: 0.58, z: 2.0 },   // Front left
                { x: 1.50, y: 0.58, z: 2.0 },    // Front right
                { x: -1.50, y: 0.58, z: -2.0 },  // Rear left
                { x: 1.50, y: 0.58, z: -2.0 }    // Rear right
            ];

            wheelPositions.forEach((pos, index) => {
                const wheelGroup = new THREE.Group();
                
                // Tire
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheelGroup.add(wheel);

                // Multi-spoke rim (7 spokes for premium look)
                const rimGeometry = new THREE.CylinderGeometry(0.35, 0.35, wheelWidth * 1.05, 12);
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.rotation.z = Math.PI / 2;
                wheelGroup.add(rim);

                // Rim spokes (7-spoke design)
                for (let i = 0; i < 7; i++) {
                    const spokeGeometry = new THREE.BoxGeometry(0.10, wheelWidth * 1.08, 0.30);
                    const spoke = new THREE.Mesh(spokeGeometry, rimMaterial);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.y = (i * Math.PI * 2) / 7;
                    wheelGroup.add(spoke);
                }

                // Center cap
                const capGeometry = new THREE.CylinderGeometry(0.18, 0.18, wheelWidth * 1.12, 16);
                const capMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.rotation.z = Math.PI / 2;
                wheelGroup.add(cap);

                // Brake disc
                const brakeGeometry = new THREE.CylinderGeometry(0.42, 0.42, 0.18, 24);
                const brakeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, 
                    metalness: 0.85, 
                    roughness: 0.55 
                });
                const brake = new THREE.Mesh(brakeGeometry, brakeMaterial);
                brake.rotation.z = Math.PI / 2;
                wheelGroup.add(brake);

                // Brake caliper (high-performance red)
                const caliperGeometry = new THREE.BoxGeometry(0.20, 0.30, 0.25);
                const caliperMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, 
                    metalness: 0.75,
                    roughness: 0.3
                });
                const caliper = new THREE.Mesh(caliperGeometry, caliperMaterial);
                caliper.position.set(pos.x > 0 ? -0.28 : 0.28, 0.12, 0);
                caliper.rotation.z = Math.PI / 2;
                wheelGroup.add(caliper);

                wheelGroup.position.set(pos.x, pos.y, pos.z);
                wheelGroup.castShadow = true;
                wheelGroup.name = `wheel_${index}`;
                carGroup.add(wheelGroup);
            });

            // === LED HEADLIGHTS - MODERN DESIGN ===
            const headlightGeometry = new THREE.BoxGeometry(0.45, 0.18, 0.10);
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0xddeeff, 
                emissiveIntensity: 0.9 
            });
            
            [-1.0, 1.0].forEach(x => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(x, 0.42, bodyLength * 0.51);
                carGroup.add(headlight);
            });
            
            // === LED DRL STRIPS ===
            [-1.15, 1.15].forEach(x => {
                const drlGeometry = new THREE.BoxGeometry(0.15, 0.05, 0.08);
                const drl = new THREE.Mesh(drlGeometry, headlightMaterial);
                drl.position.set(x, 0.32, bodyLength * 0.515);
                carGroup.add(drl);
            });

            // === LED TAILLIGHTS ===
            const taillightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000, 
                emissiveIntensity: 0.6 
            });
            
            [-1.05, 1.05].forEach(x => {
                const taillight = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.15, 0.10), taillightMaterial);
                taillight.position.set(x, 0.52, -bodyLength * 0.49);
                carGroup.add(taillight);
            });

            // === DUAL EXHAUST PIPES ===
            const exhaustGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.5, 16);
            const exhaustMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                metalness: 0.95, 
                roughness: 0.08 
            });
            
            [-0.70, 0.70].forEach(x => {
                const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position.set(x, 0.32, -bodyLength * 0.52);
                carGroup.add(exhaust);
            });
            
            // === REAR VIEW MIRRORS ===
            [-1.45, 1.45].forEach(side => {
                const mirrorBaseGeometry = new THREE.BoxGeometry(0.15, 0.12, 0.25);
                const mirrorBase = new THREE.Mesh(mirrorBaseGeometry, lipMaterial);
                mirrorBase.position.set(side, 0.85, 1.1);
                carGroup.add(mirrorBase);
                
                const mirrorGlassGeometry = new THREE.BoxGeometry(0.22, 0.15, 0.05);
                const mirrorGlassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    metalness: 0.95,
                    roughness: 0.05
                });
                const mirrorGlass = new THREE.Mesh(mirrorGlassGeometry, mirrorGlassMaterial);
                mirrorGlass.position.set(side * 1.08, 0.85, 1.15);
                mirrorGlass.rotation.y = side > 0 ? -0.3 : 0.3;
                carGroup.add(mirrorGlass);
            });

            // === SPOILER MOUNT POINT ===
            const spoilerMount = new THREE.Object3D();
            spoilerMount.position.set(0, 1.05, -bodyLength * 0.45);
            spoilerMount.name = 'spoiler_mount';
            carGroup.add(spoilerMount);

            return carGroup;
        }

        function updateCarVisuals(carMesh) {
            const stats = carConfig.calculateFinalStats();
            const performanceLevel = (stats.maxSpeed + stats.acceleration) / 300;
            
            // Dynamic color based on performance - update main body and chassis
            const hue = 0.0 + performanceLevel * 0.10;
            carMesh.children[0].material.color.setHSL(hue, 0.98, 0.42);
            if (carMesh.children[1]) {
                carMesh.children[1].material.color.setHSL(hue, 0.98, 0.42);
            }
            // Update nose color
            if (carMesh.children[4]) {
                carMesh.children[4].material.color.setHSL(hue, 0.98, 0.42);
            }

            const spoilerMount = carMesh.getObjectByName('spoiler_mount');
            if (spoilerMount) {
                while(spoilerMount.children.length > 0) {
                    spoilerMount.remove(spoilerMount.children[0]);
                }
                
                const spoilerId = carConfig.installedParts.spoiler;
                if (spoilerId !== 'spoiler_none') {
                    const spoilerHeight = spoilerId === 'spoiler_racing' ? 1.2 : 0.7;
                    const spoilerWidth = spoilerId === 'spoiler_racing' ? 2.8 : 2.4;
                    
                    const spoilerGeometry = new THREE.BoxGeometry(spoilerWidth, 0.15, 0.8);
                    const spoilerMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x0a0a0a,
                        metalness: 0.88,
                        roughness: 0.12
                    });
                    const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
                    spoiler.position.y = spoilerHeight;
                    spoiler.castShadow = true;
                    spoilerMount.add(spoiler);

                    if (spoilerId === 'spoiler_racing') {
                        const supportGeometry = new THREE.BoxGeometry(0.15, spoilerHeight, 0.15);
                        [-1.0, 1.0].forEach(x => {
                            const support = new THREE.Mesh(supportGeometry, spoilerMaterial);
                            support.position.set(x, spoilerHeight / 2, 0);
                            support.castShadow = true;
                            spoilerMount.add(support);
                        });
                        
                        // Add endplates for racing spoiler
                        [-spoilerWidth/2 + 0.1, spoilerWidth/2 - 0.1].forEach(x => {
                            const endplateGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.8);
                            const endplate = new THREE.Mesh(endplateGeometry, spoilerMaterial);
                            endplate.position.set(x, spoilerHeight, 0);
                            spoilerMount.add(endplate);
                        });
                    }
                }
            }
        }

        // ====================================================
        // GARAGE WITH STUDIO LIGHTING (FIX #1)
        // ====================================================
        function initGarage() {
            const garageViewer = document.getElementById('garage-viewer');
            
            if (!garageScene) {
                garageScene = new THREE.Scene();
                garageScene.background = new THREE.Color(0x2a2a2a);

                garageCamera = new THREE.PerspectiveCamera(50, garageViewer.clientWidth / garageViewer.clientHeight, 0.1, 1000);
                garageCamera.position.set(10, 3, 10);
                garageCamera.lookAt(0, 0.5, 0);

                garageRenderer = new THREE.WebGLRenderer({ antialias: true });
                garageRenderer.setSize(garageViewer.clientWidth, garageViewer.clientHeight);
                garageRenderer.shadowMap.enabled = true;
                garageViewer.appendChild(garageRenderer.domElement);

                // IMPROVED STUDIO LIGHTING SETUP
                // Ambient light - increased for better base visibility
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                garageScene.add(ambientLight);

                // KEY LIGHT - Main light source (front-top)
                const keyLight = new THREE.SpotLight(0xffffff, 1.8);
                keyLight.position.set(8, 12, 8);
                keyLight.angle = Math.PI / 4;
                keyLight.penumbra = 0.3;
                keyLight.castShadow = true;
                keyLight.shadow.mapSize.width = 2048;
                keyLight.shadow.mapSize.height = 2048;
                garageScene.add(keyLight);

                // FILL LIGHT - Softer light from opposite side
                const fillLight = new THREE.SpotLight(0xffffff, 0.8);
                fillLight.position.set(-8, 8, -8);
                fillLight.angle = Math.PI / 3;
                fillLight.penumbra = 0.5;
                garageScene.add(fillLight);

                // RIM/BACK LIGHT - Edge highlights and depth
                const rimLight = new THREE.SpotLight(0x88ccff, 1.2);
                rimLight.position.set(0, 6, -12);
                rimLight.angle = Math.PI / 3;
                rimLight.penumbra = 0.4;
                garageScene.add(rimLight);

                // Additional top light for even illumination
                const topLight = new THREE.DirectionalLight(0xffffff, 0.6);
                topLight.position.set(0, 15, 0);
                garageScene.add(topLight);

                // Floor with better material
                const floorGeometry = new THREE.PlaneGeometry(50, 50);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x3a3a3a, 
                    metalness: 0.4, 
                    roughness: 0.6 
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                garageScene.add(floor);

                const gridHelper = new THREE.GridHelper(50, 50, 0x00d4ff, 0x444444);
                garageScene.add(gridHelper);

                garageCarMesh = createSupercar(0xff0000);
                garageCarMesh.position.y = 0;
                garageScene.add(garageCarMesh);

                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                garageRenderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                garageRenderer.domElement.addEventListener('mousemove', (e) => {
                    if (isDragging && garageCarMesh) {
                        const deltaX = e.clientX - previousMousePosition.x;
                        garageCarMesh.rotation.y += deltaX * 0.01;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });

                garageRenderer.domElement.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                garageRenderer.domElement.addEventListener('mouseleave', () => {
                    isDragging = false;
                });
            }

            updateCarVisuals(garageCarMesh);
            renderPartsPanel();
            updateStatsDisplay();
            animateGarage();
        }

        function animateGarage() {
            if (currentState !== GameState.GARAGE) return;
            requestAnimationFrame(animateGarage);
            if (garageRenderer && garageScene && garageCamera) {
                garageRenderer.render(garageScene, garageCamera);
            }
        }

        function renderPartsPanel() {
            const tabHeaders = document.getElementById('tab-headers');
            const tabContents = document.getElementById('tab-contents');
            
            tabHeaders.innerHTML = '';
            tabContents.innerHTML = '';

            const partTypes = Object.keys(availableParts);
            
            partTypes.forEach((partType, index) => {
                const header = document.createElement('div');
                header.className = 'tab-header' + (index === 0 ? ' active' : '');
                header.setAttribute('data-i18n', partType);
                header.textContent = i18n[currentLanguage][partType] || partType;
                header.onclick = () => switchTab(partType);
                tabHeaders.appendChild(header);

                const content = document.createElement('div');
                content.className = 'tab-content' + (index === 0 ? ' active' : '');
                content.id = `tab-${partType}`;

                availableParts[partType].forEach(part => {
                    const option = document.createElement('div');
                    option.className = 'part-option';
                    
                    if (carConfig.installedParts[partType] === part.id) {
                        option.classList.add('selected');
                    }

                    const statsHTML = Object.entries(part.stats).map(([stat, value]) => {
                        const sign = value >= 0 ? '+' : '';
                        const className = value >= 0 ? 'positive' : 'negative';
                        const statName = i18n[currentLanguage][stat] || stat;
                        return `<span class="stat-badge ${className}">${statName}: ${sign}${value}</span>`;
                    }).join('');

                    option.innerHTML = `
                        <div class="part-name">${part.name}</div>
                        <div class="part-stats">${statsHTML}</div>
                    `;

                    option.addEventListener('click', () => {
                        carConfig.installPart(partType, part.id);
                        renderPartsPanel();
                        updateStatsDisplay();
                        updateCarVisuals(garageCarMesh);
                    });

                    content.appendChild(option);
                });

                tabContents.appendChild(content);
            });
        }

        function switchTab(partType) {
            document.querySelectorAll('.tab-header').forEach(h => h.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`tab-${partType}`).classList.add('active');
        }

        function updateStatsDisplay() {
            const stats = carConfig.calculateFinalStats();
            const statsGrid = document.getElementById('stats-grid');
            
            const displayStats = ['maxSpeed', 'acceleration', 'handling', 'grip'];
            
            statsGrid.innerHTML = displayStats.map(stat => {
                const value = Math.round(stats[stat] || 0);
                const statName = i18n[currentLanguage][stat] || stat;
                
                return `
                    <div class="stat-item">
                        <div class="stat-name">${statName}</div>
                        <div class="stat-value-large">${value}</div>
                    </div>
                `;
            }).join('');
        }


        // ====================================================
        // FIX #3: UNIQUE TRACK LAYOUTS FOR EACH MAP
        // ====================================================
        const trackLayouts = {
            sunset_circuit: [
                // Beginner-friendly coastal circuit with gentle curves
                { x: 0, z: 0 },
                { x: 0, z: 40 },
                { x: 20, z: 60 },
                { x: 50, z: 70 },
                { x: 80, z: 65 },
                { x: 100, z: 50 },
                { x: 110, z: 25 },
                { x: 110, z: 0 },
                { x: 100, z: -20 },
                { x: 75, z: -30 },
                { x: 45, z: -30 },
                { x: 20, z: -20 },
                { x: 0, z: 0 }
            ],
            city_streets: [
                // Urban circuit with 90-degree corners and chicanes
                { x: 0, z: 0 },
                { x: 0, z: 35 },
                { x: 5, z: 45 },
                { x: 30, z: 50 },
                { x: 35, z: 45 },
                { x: 35, z: 20 },
                { x: 40, z: 15 },
                { x: 65, z: 15 },
                { x: 70, z: 20 },
                { x: 70, z: 45 },
                { x: 75, z: 50 },
                { x: 95, z: 50 },
                { x: 100, z: 45 },
                { x: 100, z: -10 },
                { x: 95, z: -15 },
                { x: 70, z: -15 },
                { x: 65, z: -10 },
                { x: 60, z: 0 },
                { x: 55, z: -10 },
                { x: 35, z: -15 },
                { x: 5, z: -15 },
                { x: 0, z: -10 },
                { x: 0, z: 0 }
            ],
            forest_run: [
                // Twisty forest rally with elevation changes
                { x: 0, z: 0 },
                { x: 10, z: 25 },
                { x: 5, z: 40 },
                { x: 20, z: 55 },
                { x: 40, z: 60 },
                { x: 55, z: 50 },
                { x: 70, z: 55 },
                { x: 85, z: 45 },
                { x: 90, z: 25 },
                { x: 80, z: 10 },
                { x: 85, z: -5 },
                { x: 75, z: -20 },
                { x: 55, z: -25 },
                { x: 40, z: -20 },
                { x: 25, z: -30 },
                { x: 10, z: -25 },
                { x: -5, z: -15 },
                { x: -10, z: 0 },
                { x: 0, z: 0 }
            ],
            mountain_pass: [
                // Technical mountain circuit with hairpins
                { x: 0, z: 0 },
                { x: 15, z: 30 },
                { x: 35, z: 45 },
                { x: 60, z: 50 },
                { x: 85, z: 45 },
                { x: 100, z: 30 },
                { x: 105, z: 10 },
                { x: 100, z: -10 },
                { x: 85, z: -20 },
                { x: 65, z: -22 },
                { x: 50, z: -15 },
                { x: 35, z: -20 },
                { x: 20, z: -25 },
                { x: 5, z: -30 },
                { x: -10, z: -25 },
                { x: -20, z: -10 },
                { x: -20, z: 10 },
                { x: -10, z: 20 },
                { x: 0, z: 0 }
            ],
            death_valley: [
                // Expert-only high-speed circuit with dangerous corners
                { x: 0, z: 0 },
                { x: 5, z: 50 },
                { x: 25, z: 75 },
                { x: 60, z: 85 },
                { x: 100, z: 80 },
                { x: 125, z: 60 },
                { x: 135, z: 30 },
                { x: 135, z: 0 },
                { x: 130, z: -25 },
                { x: 110, z: -40 },
                { x: 85, z: -45 },
                { x: 55, z: -40 },
                { x: 30, z: -35 },
                { x: 10, z: -25 },
                { x: -5, z: -10 },
                { x: 0, z: 0 }
            ]
        };

        const maps = [
            {
                id: 'sunset_circuit',
                name: 'Sunset Beach Circuit',
                stars: 1,
                description: 'Wide coastal track with sweeping curves',
                trackWidth: 14,
                aiCount: 2,
                aiSpeed: 0.7,
                icon: 'üåÖ'
            },
            {
                id: 'city_streets',
                name: 'Downtown Grand Prix',
                stars: 2,
                description: 'Urban circuit with tight 90-degree turns',
                trackWidth: 11,
                aiCount: 3,
                aiSpeed: 0.8,
                icon: 'üèôÔ∏è'
            },
            {
                id: 'forest_run',
                name: 'Forest Rally Sprint',
                stars: 3,
                description: 'Twisting forest path with blind corners',
                trackWidth: 9,
                aiCount: 3,
                aiSpeed: 0.85,
                icon: 'üå≤'
            },
            {
                id: 'mountain_pass',
                name: 'Alpine Mountain Pass',
                stars: 4,
                description: 'Technical hairpins on cliff edges',
                trackWidth: 8,
                aiCount: 3,
                aiSpeed: 0.9,
                icon: '‚õ∞Ô∏è'
            },
            {
                id: 'death_valley',
                name: 'Death Valley Speedway',
                stars: 5,
                description: 'Extreme high-speed circuit for experts',
                trackWidth: 7,
                aiCount: 3,
                aiSpeed: 1.0,
                icon: 'üíÄ'
            }
        ];

        function renderMapSelection() {
            const mapGrid = document.getElementById('map-grid');
            mapGrid.innerHTML = '';

            maps.forEach(map => {
                const card = document.createElement('div');
                card.className = 'map-card';
                
                const stars = '‚òÖ'.repeat(map.stars) + '‚òÜ'.repeat(5 - map.stars);
                
                card.innerHTML = `
                    <div class="map-preview">${map.icon}</div>
                    <div class="map-info">
                        <div class="map-name">${map.name}</div>
                        <div class="star-rating">${stars}</div>
                        <div class="map-description">${map.description}</div>
                    </div>
                `;

                card.addEventListener('click', () => startRace(map));
                mapGrid.appendChild(card);
            });
        }

        // ====================================================
        // FIX #4: IMPROVED TRACK WITH UNIQUE LAYOUTS & VISUAL GUIDANCE
        // ====================================================
        function createRacingTrack(map) {
            const trackGroup = new THREE.Group();

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3a7d44 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            trackGroup.add(ground);

            // Get unique track layout for this map
            const waypoints = trackLayouts[map.id] || trackLayouts.sunset_circuit;
            const trackPoints = [];
            
            // Interpolate points for smooth curves
            for (let i = 0; i < waypoints.length - 1; i++) {
                const current = waypoints[i];
                const next = waypoints[i + 1];
                
                for (let t = 0; t < 1; t += 0.08) {
                    const x = current.x + (next.x - current.x) * t;
                    const z = current.z + (next.z - current.z) * t;
                    trackPoints.push(new THREE.Vector3(x, 0, z));
                }
            }

            // Create smooth track surface
            const trackCurve = new THREE.CatmullRomCurve3(trackPoints);
            trackCurve.closed = true;
            
            const trackShape = new THREE.Shape();
            const extrudePoints = trackCurve.getPoints(400);
            
            extrudePoints.forEach((point, i) => {
                if (i === 0) {
                    trackShape.moveTo(point.x, point.z);
                } else {
                    trackShape.lineTo(point.x, point.z);
                }
            });

            const trackGeometry = new THREE.ShapeGeometry(trackShape);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.9
            });
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            trackMesh.rotation.x = -Math.PI / 2;
            trackMesh.position.y = 0.02;
            trackMesh.receiveShadow = true;
            trackGroup.add(trackMesh);

            // Center line markings
            const centerLineGeometry = new THREE.PlaneGeometry(0.2, 2);
            const centerLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            for (let i = 0; i < extrudePoints.length; i += 12) {
                const point = extrudePoints[i];
                const line = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
                line.position.set(point.x, 0.03, point.z);
                line.rotation.x = -Math.PI / 2;
                
                const nextPoint = extrudePoints[(i + 1) % extrudePoints.length];
                const angle = Math.atan2(nextPoint.z - point.z, nextPoint.x - point.x);
                line.rotation.z = angle;
                
                trackGroup.add(line);
            }

            // Direction arrows for guidance
            const arrowGeometry = new THREE.ConeGeometry(0.8, 1.5, 3);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            for (let i = 0; i < extrudePoints.length; i += 40) {
                const point = extrudePoints[i];
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.set(point.x, 0.8, point.z);
                arrow.rotation.x = Math.PI / 2;
                
                const nextPoint = extrudePoints[(i + 5) % extrudePoints.length];
                const angle = Math.atan2(nextPoint.z - point.z, nextPoint.x - point.x);
                arrow.rotation.z = -angle;
                
                trackGroup.add(arrow);
            }

            // IMPROVED SMOOTH GUARDRAILS (FIX #1)
            barriers = [];
            
            // Create continuous guardrail geometry
            const guardrailHeight = 1.2;
            const guardrailWidth = 0.3;
            
            const createGuardrail = (points, isOuter) => {
                const guardrailGroup = new THREE.Group();
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const nextPoint = points[(i + 1) % points.length];
                    
                    // Calculate segment direction
                    const dx = nextPoint.x - point.x;
                    const dz = nextPoint.z - point.z;
                    const segmentLength = Math.sqrt(dx * dx + dz * dz);
                    const angle = Math.atan2(dz, dx);
                    
                    // Create guardrail segment
                    const segmentGeometry = new THREE.BoxGeometry(segmentLength, guardrailHeight, guardrailWidth);
                    const segmentMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xcc3333,
                        metalness: 0.5,
                        roughness: 0.6
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    
                    // Position at midpoint
                    segment.position.x = (point.x + nextPoint.x) / 2;
                    segment.position.y = guardrailHeight / 2;
                    segment.position.z = (point.z + nextPoint.z) / 2;
                    segment.rotation.y = angle;
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    
                    guardrailGroup.add(segment);
                    
                    // Add collision point every segment
                    barriers.push({
                        position: new THREE.Vector3(point.x, 0, point.z),
                        radius: 1.0
                    });
                }
                
                // Add support posts every few segments
                for (let i = 0; i < points.length; i += 8) {
                    const point = points[i];
                    
                    const postGeometry = new THREE.CylinderGeometry(0.12, 0.12, guardrailHeight * 1.3, 8);
                    const postMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.4
                    });
                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.set(point.x, guardrailHeight * 0.65, point.z);
                    post.castShadow = true;
                    guardrailGroup.add(post);
                }
                
                return guardrailGroup;
            };
            
            // Generate guardrail paths
            const outerGuardrailPoints = [];
            const innerGuardrailPoints = [];
            
            extrudePoints.forEach((point, i) => {
                const nextPoint = extrudePoints[(i + 1) % extrudePoints.length];
                const angle = Math.atan2(nextPoint.z - point.z, nextPoint.x - point.x);
                const distance = map.trackWidth + 0.5;
                
                // Outer guardrail points
                const outerX = point.x + Math.cos(angle + Math.PI / 2) * distance;
                const outerZ = point.z + Math.sin(angle + Math.PI / 2) * distance;
                outerGuardrailPoints.push(new THREE.Vector3(outerX, 0, outerZ));
                
                // Inner guardrail points
                const innerX = point.x - Math.cos(angle + Math.PI / 2) * distance;
                const innerZ = point.z - Math.sin(angle + Math.PI / 2) * distance;
                innerGuardrailPoints.push(new THREE.Vector3(innerX, 0, innerZ));
            });
            
            // Sample points for smoother guardrails
            const sampledOuter = [];
            const sampledInner = [];
            for (let i = 0; i < outerGuardrailPoints.length; i += 2) {
                sampledOuter.push(outerGuardrailPoints[i]);
                sampledInner.push(innerGuardrailPoints[i]);
            }
            
            const outerGuardrail = createGuardrail(sampledOuter, true);
            const innerGuardrail = createGuardrail(sampledInner, false);
            
            trackGroup.add(outerGuardrail);
            trackGroup.add(innerGuardrail);

            // Environment decorations
            const treeGeometry = new THREE.CylinderGeometry(0.6, 0.6, 10, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const leavesGeometry = new THREE.SphereGeometry(3.5, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });

            for (let i = 0; i < 80; i++) {
                const randomPoint = extrudePoints[Math.floor(Math.random() * extrudePoints.length)];
                const angle = Math.random() * Math.PI * 2;
                const distance = 25 + Math.random() * 40;
                const x = randomPoint.x + Math.cos(angle) * distance;
                const z = randomPoint.z + Math.sin(angle) * distance;

                const trunk = new THREE.Mesh(treeGeometry, treeMaterial);
                trunk.position.set(x, 5, z);
                trunk.castShadow = true;
                trackGroup.add(trunk);

                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, 10, z);
                leaves.castShadow = true;
                trackGroup.add(leaves);
            }

            trackGroup.userData.trackPoints = extrudePoints;
            
            // ====================================================
            // FIX #5: START/FINISH GATE (VISIBLE LAP CHECKPOINT)
            // ====================================================
            const gateWidth = map.trackWidth * 2;
            const gateHeight = 6;
            
            // Gate posts (left and right)
            const postGeometry = new THREE.CylinderGeometry(0.4, 0.4, gateHeight, 12);
            const postMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            
            const leftPost = new THREE.Mesh(postGeometry, postMaterial);
            leftPost.position.set(-gateWidth / 2, gateHeight / 2, 0);
            leftPost.castShadow = true;
            trackGroup.add(leftPost);
            
            const rightPost = new THREE.Mesh(postGeometry, postMaterial);
            rightPost.position.set(gateWidth / 2, gateHeight / 2, 0);
            rightPost.castShadow = true;
            trackGroup.add(rightPost);
            
            // Gate arch (top beam)
            const archGeometry = new THREE.BoxGeometry(gateWidth, 0.6, 0.6);
            const archMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffff00,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xffff00,
                emissiveIntensity: 0.6
            });
            const arch = new THREE.Mesh(archGeometry, archMaterial);
            arch.position.set(0, gateHeight - 0.3, 0);
            arch.castShadow = true;
            trackGroup.add(arch);
            
            // Checkered pattern panels
            for (let side of [-1, 1]) {
                const panelGeometry = new THREE.PlaneGeometry(0.4, gateHeight * 0.7);
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Draw checkered pattern
                const squareSize = 16;
                for (let y = 0; y < 128; y += squareSize) {
                    for (let x = 0; x < 64; x += squareSize) {
                        ctx.fillStyle = ((x/squareSize) + (y/squareSize)) % 2 === 0 ? '#ffffff' : '#000000';
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                const panelMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.DoubleSide
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(side * (gateWidth / 2 - 0.5), gateHeight * 0.4, 0);
                trackGroup.add(panel);
            }
            
            // "START" text at top of gate
            const createTextBanner = (text, yPos) => {
                const bannerGeometry = new THREE.PlaneGeometry(gateWidth * 0.8, 1.2);
                const bannerCanvas = document.createElement('canvas');
                bannerCanvas.width = 512;
                bannerCanvas.height = 128;
                const bannerCtx = bannerCanvas.getContext('2d');
                
                bannerCtx.fillStyle = '#000000';
                bannerCtx.fillRect(0, 0, 512, 128);
                bannerCtx.fillStyle = '#00ff00';
                bannerCtx.font = 'bold 80px Arial';
                bannerCtx.textAlign = 'center';
                bannerCtx.textBaseline = 'middle';
                bannerCtx.fillText(text, 256, 64);
                
                const bannerTexture = new THREE.CanvasTexture(bannerCanvas);
                const bannerMaterial = new THREE.MeshBasicMaterial({ 
                    map: bannerTexture,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
                banner.position.set(0, yPos, 0);
                return banner;
            };
            
            const startBanner = createTextBanner('START / FINISH', gateHeight - 1.5);
            trackGroup.add(startBanner);
            
            // Store start/finish line data
            trackGroup.userData.startFinishLine = {
                position: new THREE.Vector3(0, 0, 0),
                width: gateWidth,
                normal: new THREE.Vector3(0, 0, 1) // Direction perpendicular to line
            };
            
            return trackGroup;
        }
        
        // ====================================================
        // FIX #4: LAP DETECTION LOGIC
        // ====================================================
        function checkLapCompletion() {
            if (!startFinishLine || !raceStarted) return;
            
            const linePos = startFinishLine.position;
            const lineNormal = startFinishLine.normal;
            
            // Calculate car's position relative to start line
            const carToLine = new THREE.Vector3()
                .subVectors(carPosition, linePos);
            
            const dotProduct = carToLine.dot(lineNormal);
            
            // Check if car crossed the line
            if (lastLapCheckPosition !== null) {
                const lastDot = lastLapCheckPosition;
                
                // Crossed from back to front (correct direction)
                if (lastDot < 0 && dotProduct >= 0 && hasPassedStartLine) {
                    // Valid lap completed!
                    lapCount++;
                    hasPassedStartLine = false;
                    
                    // Show lap completed feedback
                    if (lapCount <= 3) {
                        showSkillFeedback(`LAP ${lapCount}/3`, '#00ff00');
                    } else if (lapCount > 3) {
                        // Race finished!
                        showSkillFeedback('RACE COMPLETE!', '#ffff00');
                        setTimeout(() => {
                            showIntro();
                        }, 3000);
                    }
                    
                    document.getElementById('lap-display').textContent = `${Math.min(lapCount, 3)}/3`;
                }
                
                // Mark that car has moved away from start line
                if (Math.abs(dotProduct) > 10) {
                    hasPassedStartLine = true;
                }
            }
            
            lastLapCheckPosition = dotProduct;
        }
        
        function showSkillFeedback(text, color) {
            const feedback = document.getElementById('skill-feedback');
            feedback.textContent = text;
            feedback.style.borderColor = color;
            feedback.style.color = color;
            feedback.style.display = 'block';
            feedback.style.animation = 'feedbackPop 2s';
            
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 2000);
        }

        // ====================================================
        // FIX #4 & #5: AI WITH BOUNDS CHECKING & FIXED DIRECTION
        // ====================================================
        class AIOpponent {
            constructor(trackPoints, offset, speedMultiplier, difficulty) {
                this.mesh = createSupercar(Math.random() * 0xffffff);
                this.trackPoints = trackPoints;
                this.currentPointIndex = Math.floor(offset * trackPoints.length);
                this.speedMultiplier = speedMultiplier;
                this.difficulty = difficulty;
                this.speed = 0;
                this.baseMaxSpeed = 2.2 + speedMultiplier * 1.8;
                this.maxSpeed = this.baseMaxSpeed;
                this.position = new THREE.Vector3();
                this.rotation = 0;
                this.isInCorner = false;
                this.lastValidPosition = new THREE.Vector3();
                this.outOfBoundsFrames = 0;
                
                const startPoint = trackPoints[this.currentPointIndex];
                this.position.copy(startPoint);
                this.lastValidPosition.copy(startPoint);
                this.mesh.position.copy(startPoint);
                this.mesh.position.y = 0;
            }

            detectCorner() {
                // Look ahead to detect corners
                const lookAheadDistance = 8;
                const currentPoint = this.trackPoints[this.currentPointIndex];
                const futureIndex = (this.currentPointIndex + lookAheadDistance) % this.trackPoints.length;
                const futurePoint = this.trackPoints[futureIndex];
                
                const midIndex = (this.currentPointIndex + Math.floor(lookAheadDistance / 2)) % this.trackPoints.length;
                const midPoint = this.trackPoints[midIndex];
                
                // Calculate angle change
                const angle1 = Math.atan2(midPoint.z - currentPoint.z, midPoint.x - currentPoint.x);
                const angle2 = Math.atan2(futurePoint.z - midPoint.z, futurePoint.x - midPoint.x);
                
                let angleDiff = Math.abs(angle2 - angle1);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // Sharp corner if angle change is significant
                return angleDiff > 0.3;
            }

            isOutOfBounds() {
                // Check if AI is too far from track
                const currentWaypoint = this.trackPoints[this.currentPointIndex];
                const distanceFromTrack = this.position.distanceTo(currentWaypoint);
                
                // Check height (prevent falling through floor)
                const isBelowGround = this.mesh.position.y < -5;
                
                // Check horizontal distance from track
                const isTooFarFromTrack = distanceFromTrack > 50;
                
                return isBelowGround || isTooFarFromTrack;
            }

            resetToTrack() {
                // Reset AI to last valid position on track
                this.position.copy(this.lastValidPosition);
                this.mesh.position.copy(this.lastValidPosition);
                this.mesh.position.y = 0;
                this.speed *= 0.5; // Reduce speed after reset
                this.outOfBoundsFrames = 0;
            }

            update(deltaTime) {
                // Detect if approaching corner
                this.isInCorner = this.detectCorner();
                
                // Adjust target speed based on corner detection
                if (this.isInCorner) {
                    // Brake for corners
                    this.maxSpeed = this.baseMaxSpeed * 0.58;
                } else {
                    // Accelerate on straights
                    this.maxSpeed = this.baseMaxSpeed;
                }
                
                // Smooth acceleration/braking
                const accelRate = this.isInCorner ? 1.8 : 3.2;
                this.speed = THREE.MathUtils.lerp(this.speed, this.maxSpeed, deltaTime * accelRate);
                
                // Navigate along racing line - FIXED DIRECTION
                const targetIndex = (this.currentPointIndex + 1) % this.trackPoints.length;
                const currentPoint = this.trackPoints[this.currentPointIndex];
                const targetPoint = this.trackPoints[targetIndex];
                
                const direction = new THREE.Vector3()
                    .subVectors(targetPoint, currentPoint)
                    .normalize();
                
                // Move forward - AI NEVER reverses
                this.position.add(direction.multiplyScalar(this.speed * deltaTime * 11));
                
                // Check if reached waypoint
                const distance = this.position.distanceTo(targetPoint);
                if (distance < 2.5) {
                    this.currentPointIndex = targetIndex;
                    // Save valid position when reaching waypoint
                    this.lastValidPosition.copy(this.position);
                }
                
                // CRITICAL: Bounds checking to prevent disappearing
                if (this.isOutOfBounds()) {
                    this.outOfBoundsFrames++;
                    if (this.outOfBoundsFrames > 10) {
                        // Reset to track if out of bounds for too long
                        console.warn('AI car reset to track - was out of bounds');
                        this.resetToTrack();
                    }
                } else {
                    this.outOfBoundsFrames = 0;
                    // Update last valid position
                    this.lastValidPosition.copy(this.position);
                }
                
                // Calculate rotation - always forward along track
                this.rotation = Math.atan2(direction.z, direction.x) - Math.PI / 2;
                
                // Update mesh - ENSURE it stays visible
                this.mesh.position.copy(this.position);
                this.mesh.position.y = Math.max(0, this.mesh.position.y); // Never below ground
                this.mesh.rotation.y = this.rotation;
                
                // Tilt car in corners
                const tiltAmount = this.isInCorner ? 0.12 : 0;
                this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, tiltAmount, deltaTime * 3);
                
                // Keep mesh visible in scene
                this.mesh.visible = true;
            }
        }

        // ====================================================
        // COLLISION DETECTION (FIX #3)
        // ====================================================
        function checkBarrierCollision(position) {
            for (let barrier of barriers) {
                const distance = position.distanceTo(barrier.position);
                if (distance < barrier.radius + 1.5) {
                    // Calculate collision normal
                    const normal = new THREE.Vector3()
                        .subVectors(position, barrier.position)
                        .normalize();
                    
                    // Push car away from barrier
                    const pushDistance = (barrier.radius + 1.5) - distance;
                    position.add(normal.multiplyScalar(pushDistance));
                    
                    return true;
                }
            }
            return false;
        }

        // ====================================================
        // RACING GAME LOGIC
        // ====================================================
        let currentMap = null;
        let carPosition = new THREE.Vector3(0, 0, 0);
        let carRotation = 0;
        let carSpeed = 0;
        let steeringAngle = 0;
        let lapCount = 1;
        let trackPoints = [];
        let lateralVelocity = 0;  // For drift mechanics
        let stabilityFactor = 1.0; // Stability control
        
        // Countdown system
        let countdownActive = false;
        let countdownValue = 3;
        let raceStarted = false;
        
        // Lap detection system
        let startFinishLine = null;
        let hasPassedStartLine = false;
        let lastLapCheckPosition = null;

        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        function startRace(map) {
            currentMap = map;
            setState(GameState.RACING);
            
            while(scene.children.length > 0) {
                const child = scene.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                scene.remove(child);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 150, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            track = createRacingTrack(map);
            scene.add(track);
            trackPoints = track.userData.trackPoints;

            playerCar = createSupercar(0xff0000);
            playerCar.position.set(0, 0, 0);
            scene.add(playerCar);
            updateCarVisuals(playerCar);

            aiCars = [];
            for (let i = 0; i < map.aiCount; i++) {
                const ai = new AIOpponent(
                    trackPoints, 
                    (i + 1) / (map.aiCount + 1), 
                    map.aiSpeed,
                    map.stars
                );
                scene.add(ai.mesh);
                aiCars.push(ai);
            }

            carPosition.set(0, 0, 0);
            carSpeed = 0;
            carRotation = 0;
            steeringAngle = 0;
            lateralVelocity = 0;
            stabilityFactor = 1.0;
            lapCount = 1;
            
            // Initialize lap detection system
            startFinishLine = track.userData.startFinishLine;
            hasPassedStartLine = false;
            lastLapCheckPosition = null;

            document.getElementById('position-total').textContent = `/${map.aiCount + 1}`;

            // Initialize camera BEFORE countdown
            camera.position.set(carPosition.x, 5, carPosition.z - 10);
            camera.lookAt(carPosition.x, 0, carPosition.z);
            
            // Render initial scene so camera is visible
            renderer.render(scene, camera);
            
            lastTime = performance.now();
            
            // START COUNTDOWN SEQUENCE
            startCountdown();
            
            gameLoop();
        }

        // ====================================================
        // FIX #6: RACE START COUNTDOWN SYSTEM
        // ====================================================
        function startCountdown() {
            countdownActive = true;
            raceStarted = false;
            countdownValue = 3;
            
            const countdownDisplay = document.getElementById('countdown-display');
            countdownDisplay.style.display = 'block';
            countdownDisplay.classList.remove('go');
            
            function showCountdownNumber() {
                if (countdownValue > 0) {
                    countdownDisplay.textContent = countdownValue;
                    countdownDisplay.style.animation = 'none';
                    setTimeout(() => {
                        countdownDisplay.style.animation = 'countdownPulse 1s ease-out';
                    }, 10);
                    
                    countdownValue--;
                    setTimeout(showCountdownNumber, 1000);
                } else {
                    // Show GO!
                    countdownDisplay.textContent = 'GO!';
                    countdownDisplay.classList.add('go');
                    countdownDisplay.style.animation = 'none';
                    setTimeout(() => {
                        countdownDisplay.style.animation = 'countdownPulse 1s ease-out';
                    }, 10);
                    
                    // Enable racing after 800ms
                    setTimeout(() => {
                        countdownActive = false;
                        raceStarted = true;
                        countdownDisplay.style.display = 'none';
                    }, 800);
                }
            }
            
            showCountdownNumber();
        }

        // ====================================================
        // CONTROLS - BLOCKED DURING COUNTDOWN
        // ====================================================
        document.addEventListener('keydown', (e) => {
            if (currentState !== GameState.RACING) return;
            if (countdownActive || !raceStarted) return; // Block input during countdown
            
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys.forward = true;
                    break;
                case 's':
                case 'arrowdown':
                    keys.backward = true;
                    break;
                case 'a':
                case 'arrowleft':
                    keys.left = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys.forward = false;
                    break;
                case 's':
                case 'arrowdown':
                    keys.backward = false;
                    break;
                case 'a':
                case 'arrowleft':
                    keys.left = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = false;
                    break;
                case 'escape':
                    if (currentState === GameState.RACING && raceStarted) {
                        showIntro();
                    }
                    break;
            }
        });

        // ====================================================
        // CRITICAL PHYSICS FIXES - NO ROTATION AT 0 KM/H
        // ====================================================
        function updatePhysics(deltaTime) {
            // Only update physics if race has started
            if (!raceStarted) return;
            
            const stats = carConfig.calculateFinalStats();
            
            const maxSpeedFactor = stats.maxSpeed / 100;
            const accelerationFactor = stats.acceleration / 100;
            const handlingFactor = stats.handling / 100;
            const gripFactor = stats.grip / 100;
            const stabilityBonus = (stats.stability || 100) / 100;

            // IMPROVED ACCELERATION CURVE (FIX #3)
            const maxSpeed = 2.5 + maxSpeedFactor * 2.0;
            const currentSpeedRatio = Math.abs(carSpeed) / maxSpeed;
            
            // Smooth acceleration curve with exponential falloff
            const accelPower = Math.pow(1.0 - currentSpeedRatio, 1.8);
            
            if (keys.forward) {
                const baseAccel = 0.045 * accelerationFactor * accelPower;
                carSpeed += baseAccel * deltaTime * 60;
            } else if (keys.backward) {
                const baseAccel = 0.035 * accelerationFactor * accelPower;
                carSpeed -= baseAccel * deltaTime * 60;
            } else {
                // Natural deceleration
                carSpeed *= 0.96;
            }

            // Enforce speed limits
            carSpeed = Math.max(-maxSpeed * 0.6, Math.min(carSpeed, maxSpeed));

            // CRITICAL FIX #2: NO ROTATION AT ZERO SPEED
            const absSpeed = Math.abs(carSpeed);
            const speedFactor = absSpeed / maxSpeed;
            
            // Minimum speed required for any rotation (realistic)
            const minRotationSpeed = 0.1;
            
            if (absSpeed < minRotationSpeed) {
                // At very low/zero speed, NO rotation allowed
                steeringAngle *= 0.7; // Decay steering input
                // Skip all rotation logic
            } else {
                // SPEED-BASED STEERING (only when moving)
                // Maximum steering angle decreases with speed
                const maxSteerAngle = 0.42 * (1.0 - speedFactor * 0.65) * handlingFactor;
                const steerSpeed = 2.2;
                
                if (keys.left) {
                    steeringAngle = Math.min(steeringAngle + steerSpeed * deltaTime, maxSteerAngle);
                } else if (keys.right) {
                    steeringAngle = Math.max(steeringAngle - steerSpeed * deltaTime, -maxSteerAngle);
                } else {
                    // Return to center smoothly
                    steeringAngle *= 0.88;
                }

                // GRIP-BASED TURN RATE (only when moving)
                const gripMultiplier = 0.8 + (gripFactor * 0.4);
                
                // Rotation power increases with speed (realistic)
                const rotationPower = Math.min(absSpeed / minRotationSpeed, 1.0);
                const baseTurnRate = steeringAngle * gripMultiplier * rotationPower;
                
                // At high speed, reduce turn rate (wider turning radius)
                const speedPenalty = Math.pow(speedFactor, 1.6);
                const turnRate = baseTurnRate * (1.2 - speedPenalty);
                
                // STABILITY CONTROL - Limit rotation rate
                const maxRotationPerFrame = 0.075 * stabilityBonus;
                const clampedTurnRate = Math.max(-maxRotationPerFrame, Math.min(turnRate, maxRotationPerFrame));
                
                // Apply rotation
                const targetRotationDelta = clampedTurnRate * deltaTime * 60;
                carRotation += targetRotationDelta;

                // DRIFT MECHANICS - Controlled sliding (only at speed)
                const driftThreshold = 0.7;
                if (speedFactor > driftThreshold && Math.abs(steeringAngle) > 0.2) {
                    const driftAmount = (speedFactor - driftThreshold) * Math.abs(steeringAngle) * 0.25;
                    lateralVelocity += driftAmount * (steeringAngle > 0 ? 1 : -1);
                }
            }
            
            // Gradually recover from drift
            lateralVelocity *= 0.90 * gripFactor;
            lateralVelocity = Math.max(-0.4, Math.min(lateralVelocity, 0.4));

            // Calculate movement
            const moveX = Math.sin(carRotation) * carSpeed * deltaTime * 60;
            const moveZ = Math.cos(carRotation) * carSpeed * deltaTime * 60;
            
            // Add lateral drift component
            const lateralX = Math.cos(carRotation) * lateralVelocity * deltaTime * 60;
            const lateralZ = -Math.sin(carRotation) * lateralVelocity * deltaTime * 60;

            carPosition.x += moveX + lateralX;
            carPosition.z += moveZ + lateralZ;

            // IMPROVED COLLISION DETECTION
            const collided = checkBarrierCollision(carPosition);
            if (collided) {
                carSpeed *= 0.3; // Strong slowdown on collision
                lateralVelocity *= 0.3;
            }

            // Update car mesh
            playerCar.position.copy(carPosition);
            playerCar.rotation.y = carRotation;

            // Realistic car tilt during turns (only when moving)
            const tilt = absSpeed > minRotationSpeed ? (-steeringAngle * 0.2 * speedFactor) : 0;
            playerCar.rotation.z = THREE.MathUtils.lerp(playerCar.rotation.z, tilt, deltaTime * 5);

            // CAMERA - Improved positioning
            const cameraDistance = 14;
            const cameraHeight = 6;
            const cameraOffsetY = 2.5;
            
            const targetCameraX = carPosition.x - Math.sin(carRotation) * cameraDistance;
            const targetCameraZ = carPosition.z - Math.cos(carRotation) * cameraDistance;
            const targetCameraY = carPosition.y + cameraHeight;

            camera.position.x += (targetCameraX - camera.position.x) * 0.12;
            camera.position.y += (targetCameraY - camera.position.y) * 0.12;
            camera.position.z += (targetCameraZ - camera.position.z) * 0.12;

            const lookAheadDistance = 6;
            const lookAtX = carPosition.x + Math.sin(carRotation) * lookAheadDistance;
            const lookAtZ = carPosition.z + Math.cos(carRotation) * lookAheadDistance;
            const lookAtY = carPosition.y + cameraOffsetY;
            
            camera.lookAt(lookAtX, lookAtY, lookAtZ);

            // Update AI
            aiCars.forEach(ai => ai.update(deltaTime));

            // Check lap completion
            checkLapCompletion();

            // Update HUD
            document.getElementById('speed-display').textContent = Math.abs(Math.round(carSpeed * 60));
            document.getElementById('lap-display').textContent = `${lapCount}/3`;

            updateMinimap();
        }

        // ====================================================
        // MINIMAP
        // ====================================================
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, 200, 200);

            if (trackPoints.length === 0) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            trackPoints.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minZ = Math.min(minZ, point.z);
                maxZ = Math.max(maxZ, point.z);
            });

            const scaleX = 180 / (maxX - minX);
            const scaleZ = 180 / (maxZ - minZ);
            const scale = Math.min(scaleX, scaleZ);

            // Draw track
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            trackPoints.forEach((point, i) => {
                const x = ((point.x - minX) * scale) + 10;
                const y = ((point.z - minZ) * scale) + 10;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke();

            // Draw AI cars
            ctx.fillStyle = '#ff6600';
            aiCars.forEach(ai => {
                const x = ((ai.position.x - minX) * scale) + 10;
                const y = ((ai.position.z - minZ) * scale) + 10;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player car
            ctx.fillStyle = '#00ff00';
            const playerX = ((carPosition.x - minX) * scale) + 10;
            const playerY = ((carPosition.z - minZ) * scale) + 10;
            ctx.beginPath();
            ctx.arc(playerX, playerY, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // ====================================================
        // GAME LOOP - RENDERS DURING COUNTDOWN
        // ====================================================
        let lastTime = 0;

        function gameLoop() {
            if (currentState !== GameState.RACING) return;

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Update physics only if race has started
            if (raceStarted) {
                updatePhysics(deltaTime);
            } else {
                // During countdown, keep camera updated so player can see
                const cameraDistance = 14;
                const cameraHeight = 6;
                camera.position.set(
                    carPosition.x - Math.sin(carRotation) * cameraDistance,
                    carPosition.y + cameraHeight,
                    carPosition.z - Math.cos(carRotation) * cameraDistance
                );
                camera.lookAt(carPosition.x, carPosition.y + 2, carPosition.z + 5);
            }

            // Always render scene (even during countdown)
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        // ====================================================
        // SETTINGS
        // ====================================================
        function toggleMusic() {
            const toggle = document.getElementById('music-toggle');
            toggle.classList.toggle('active');
        }

        function toggleSound() {
            const toggle = document.getElementById('sound-toggle');
            toggle.classList.toggle('active');
        }

        // ====================================================
        // INITIALIZATION
        // ====================================================
        window.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            
            const savedLanguage = localStorage.getItem('language') || 'en';
            document.getElementById('language-select').value = savedLanguage;
            changeLanguage(savedLanguage);

            const savedTheme = localStorage.getItem('theme') || 'neon';
            changeTheme(savedTheme);

            function animate() {
                requestAnimationFrame(animate);
                if (currentState === GameState.INTRO) {
                    renderer.render(scene, camera);
                }
            }
            animate();
        });
    </script>
</body>
</html>