<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meteor Smash</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 720px;
            height: 100vh;
            max-height: 1280px;
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        @media (min-width: 721px) {
            #gameContainer {
                width: 720px;
                height: 1280px;
            }
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #touchLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: none;
        }

        #touchLayer.active {
            display: block;
        }

        .hud-element {
            position: absolute;
            z-index: 5;
            pointer-events: none;
        }

        #hearts {
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .heart {
            width: 40px;
            height: 40px;
            background: #ff0066;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            filter: drop-shadow(0 0 10px #ff0066);
            animation: heartbeat 1.5s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #levelHud {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .level-text {
            color: #00ffff;
            font-size: 20px;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 5px;
        }

        .xp-bar {
            width: 250px;
            height: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #7fff00);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 15px #00ff00;
        }

        #currency {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .currency-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 20px;
            padding: 8px 15px;
            color: #fff;
            font-size: 16px;
            filter: drop-shadow(0 0 8px #00ff00);
        }

        .game-button {
            position: absolute;
            padding: 15px 30px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            filter: drop-shadow(0 0 20px #00ff00);
            transition: all 0.2s;
            z-index: 20;
            pointer-events: auto;
        }

        .game-button:hover, .game-button:active {
            transform: scale(1.1);
            filter: drop-shadow(0 0 30px #00ff00);
        }

        #pauseBtn {
            top: 130px;
            right: 20px;
            width: 60px;
            height: 60px;
            padding: 0;
            border-radius: 50%;
            font-size: 28px;
            display: none;
        }

        #pauseBtn.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 100;
        }

        #pauseMenu.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .pause-title {
            font-size: 64px;
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            margin-bottom: 60px;
            animation: pulse 2s infinite;
        }

        .pause-menu-button {
            padding: 20px 60px;
            margin: 15px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            filter: drop-shadow(0 0 20px #00ff00);
            transition: all 0.2s;
        }

        .pause-menu-button:hover, .pause-menu-button:active {
            transform: scale(1.1);
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2e 0%, #16213e 30%, #1a1a3e 70%, #0a0a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow: hidden;
        }

        #loadingScreen::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #loadingScreen.hidden {
            animation: fadeOut 0.5s ease-out forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        .loading-title {
            font-size: 72px;
            background: linear-gradient(45deg, #00ffff, #00ff00, #00ffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: float 3s ease-in-out infinite, gradientShift 3s ease-in-out infinite;
            text-align: center;
            margin-bottom: 60px;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
            position: relative;
            z-index: 1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .loading-bar {
            width: 400px;
            max-width: 80%;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 1;
        }

        .loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            to { left: 100%; }
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff, #00ff00);
            background-size: 200% 100%;
            width: 0%;
            animation: loadProgress 3s ease-in-out forwards, waveEffect 1.5s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            position: relative;
        }

        @keyframes loadProgress {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        @keyframes waveEffect {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1f 0%, #1a1a3e 50%, #0a0a1f 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        #mainMenu.active {
            display: flex;
        }

        .menu-title {
            font-size: min(80px, 15vw);
            color: #00ffff;
            text-shadow: 0 0 50px #00ffff;
            margin-bottom: 80px;
            animation: float 3s ease-in-out infinite;
            text-align: center;
            line-height: 1.2;
        }

        .menu-button {
            width: 280px;
            padding: 20px 40px;
            margin: 15px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 4px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
            text-align: center;
        }

        .menu-button:hover, .menu-button:active {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(0, 255, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
        }

        .menu-button.secondary {
            background: linear-gradient(135deg, #00ffff, #00cccc);
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .menu-button.secondary:hover, .menu-button.secondary:active {
            box-shadow: 0 0 50px rgba(0, 255, 255, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
        }

        #skillScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 40px 20px;
            overflow-y: auto;
        }

        #skillScreen.active {
            display: flex;
        }

        .skill-title {
            font-size: clamp(24px, 6vw, 48px);
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            margin-bottom: 30px;
            text-align: center;
        }

        #skillsContainer {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .skill-card {
            width: min(200px, 30vw);
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a4e 100%);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .skill-card:hover, .skill-card:active {
            transform: translateY(-10px);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
        }

        .skill-card.selected {
            border-color: #00ff00;
            background: linear-gradient(135deg, #2a4a2a 0%, #3a5a3a 100%);
            transform: translateY(-10px) scale(1.05);
        }

        .skill-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }

        .skill-name {
            font-size: 18px;
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .skill-description {
            font-size: 13px;
            color: #aaa;
            line-height: 1.4;
        }

        #confirmSkill {
            padding: 20px 50px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            filter: drop-shadow(0 0 20px #00ff00);
        }

        #confirmSkill:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #gameOverScreen.active {
            display: flex;
        }

        .game-over-title {
            font-size: clamp(48px, 10vw, 72px);
            color: #ff0066;
            text-shadow: 0 0 40px #ff0066;
            margin-bottom: 40px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .final-score {
            font-size: clamp(24px, 5vw, 36px);
            color: #00ffff;
            margin-bottom: 60px;
        }

        .game-over-button {
            padding: 20px 50px;
            margin: 15px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .game-over-button:hover, .game-over-button:active {
            transform: scale(1.1);
        }

        #helpScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 150;
            overflow-y: auto;
        }

        #helpScreen.active {
            display: block;
        }

        .help-container {
            max-width: 600px;
            margin: 40px auto;
            padding: 30px 20px;
        }

        .help-header {
            font-size: clamp(32px, 8vw, 48px);
            color: #00ff00;
            text-align: center;
            margin-bottom: 40px;
        }

        .help-section {
            background: rgba(26, 26, 62, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .help-section-title {
            font-size: clamp(20px, 5vw, 28px);
            color: #00ffff;
            margin-bottom: 20px;
        }

        .help-text {
            font-size: 16px;
            color: #ccc;
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .close-help-btn {
            display: block;
            margin: 30px auto;
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }

        #bossWarning {
            position: absolute;
            top: 50%;
            left: 50px;
            transform: translateY(-50%);
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 50px #ff0000;
            z-index: 90;
            display: none;
            animation: bossWarningPulse 1s infinite;
            pointer-events: none;
            text-align: left;
        }

        @keyframes bossWarningPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.5; transform: translateY(-50%) scale(1.1); }
        }

        #bossWarning.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="720" height="1280"></canvas>
        <canvas id="touchLayer"></canvas>
        
        <div id="hearts" class="hud-element"></div>
        
        <div id="levelHud" class="hud-element">
            <div class="level-text">Level <span id="levelNum">1</span></div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpFill"></div>
            </div>
        </div>
        
        <div id="currency" class="hud-element">
            <div class="currency-display">‚≠ê <span id="scoreDisplay">0</span></div>
            <div class="currency-display">üí∞ <span id="coinDisplay">0</span></div>
        </div>
        
        <div id="bossWarning">‚ö†Ô∏è BOSS APPROACHING ‚ö†Ô∏è</div>
        
        <div id="bossTimer" class="hud-element" style="top: 100px; left: 50%; transform: translateX(-50%); display: none;">
            <div style="background: rgba(0,0,0,0.8); border: 2px solid #ff0000; border-radius: 10px; padding: 10px 20px; text-align: center;">
                <div style="color: #ff0000; font-size: 14px; margin-bottom: 5px;">üëπ NEXT BOSS</div>
                <div id="bossTimerText" style="color: #fff; font-size: 20px; font-weight: bold;">3:00</div>
            </div>
        </div>
        
        <button id="pauseBtn" class="game-button" onclick="game.togglePause()">‚è∏</button>
        
        <div id="loadingScreen">
            <div class="loading-title">METEOR SMASH</div>
            <div class="loading-bar">
                <div class="loading-fill"></div>
            </div>
        </div>
        
        <div id="mainMenu">
            <div class="menu-title">METEOR<br>SMASH</div>
            <button class="menu-button" onclick="game.startGame()">‚ñ∂ PLAY</button>
            <button class="menu-button secondary" onclick="game.showHelp()">‚ùì HOW TO PLAY</button>
        </div>
        
        <div id="pauseMenu">
            <div class="pause-title">‚è∏ PAUSED</div>
            <button class="pause-menu-button" onclick="game.resumeGame()">‚ñ∂ RESUME</button>
            <button class="pause-menu-button" onclick="game.returnToMainMenu()">üè† MAIN MENU</button>
        </div>
        
        <div id="skillScreen">
            <div class="skill-title">‚¨ÜÔ∏è LEVEL UP! Choose an Upgrade:</div>
            <div id="skillsContainer"></div>
            <button id="confirmSkill" onclick="game.confirmSkill()" disabled>‚úÖ CONFIRM</button>
        </div>
        
        <div id="gameOverScreen">
            <div class="game-over-title">üíÄ GAME OVER</div>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <button class="game-over-button" onclick="game.restart()">üîÑ PLAY AGAIN</button>
            <button class="game-over-button" onclick="game.backToMenu()">üè† MAIN MENU</button>
        </div>
        
        <div id="helpScreen">
            <div class="help-container">
                <div class="help-header">üìñ HOW TO PLAY</div>
                
                <div class="help-section">
                    <div class="help-section-title">üéÆ Controls</div>
                    <p class="help-text">Desktop: Use WASD or Arrow Keys to move</p>
                    <p class="help-text">Mobile: Touch and drag to move</p>
                    <p class="help-text">Your ship fires automatically!</p>
                </div>

                <div class="help-section">
                    <div class="help-section-title">üëæ Bosses</div>
                    <p class="help-text">Powerful bosses appear every 3 minutes!</p>
                    <p class="help-text">Each boss has unique attack patterns</p>
                    <p class="help-text">Defeat them for massive rewards!</p>
                </div>

                <div class="help-section">
                    <div class="help-section-title">üéØ Skills</div>
                    <p class="help-text">üî´ Support Fighters - Summon fighters to assist</p>
                    <p class="help-text">üí• Explosive Rounds - Bullets explode on impact</p>
                    <p class="help-text">‚ö° Chain Lightning - Periodic lightning chains</p>
                    <p class="help-text">üöÄ Homing Missiles - Heat-seeking missiles</p>
                    <p class="help-text">üîÑ Ricochet Bullets - Bullets bounce off targets</p>
                    <p class="help-text">üéØ Piercing Bullets - Penetrate multiple enemies</p>
                    <p class="help-text">üî¥ Laser Fortress - Continuous laser support</p>
                </div>
            </div>
            <button class="close-help-btn" onclick="game.closeHelp()">‚úÖ GOT IT!</button>
        </div>
    </div>

    <script>
        const SKILLS = {
            support_fighters: {
                id: 'support_fighters',
                name: 'Extra Firepower',
                icon: 'üî´',
                description: 'Support Fighters',
                maxTier: 2,
                conflicts: []
            },
            explosive_bullets: {
                id: 'explosive_bullets',
                name: 'Explosive Rounds',
                icon: 'üí•',
                description: 'Bullets explode on impact',
                maxTier: 2,
                conflicts: []
            },
            chain_lightning: {
                id: 'chain_lightning',
                name: 'Chain Lightning',
                icon: '‚ö°',
                description: 'Periodic lightning chains',
                maxTier: 2,
                conflicts: []
            },
            homing_missiles: {
                id: 'homing_missiles',
                name: 'Homing Missiles',
                icon: 'üöÄ',
                description: 'Heat-seeking missiles',
                maxTier: 2,
                conflicts: []
            },
            ricochet_bullets: {
                id: 'ricochet_bullets',
                name: 'Ricochet Bullets',
                icon: 'üîÅ',
                description: 'Bullets bounce off targets',
                maxTier: 2,
                conflicts: ['piercing_bullets']
            },
            piercing_bullets: {
                id: 'piercing_bullets',
                name: 'Piercing Bullets',
                icon: 'üéØ',
                description: 'Penetrate multiple enemies',
                maxTier: 2,
                conflicts: ['ricochet_bullets']
            },
            laser_fortress: {
                id: 'laser_fortress',
                name: 'Laser Fortress',
                icon: 'üî¥',
                description: 'Continuous laser support',
                maxTier: 2,
                conflicts: []
            }
        };

        // BOSS DEFINITIONS
        const BOSSES = {
            // Boss 1: Flame Demon - Fire-based attacks
            flame_demon: {
                id: 'flame_demon',
                name: 'Flame Demon',
                hp: 1000,
                size: 150,
                color: '#ff3300',
                skills: [
                    {
                        name: 'Fire Circle',
                        cooldown: 3000,
                        execute: function(boss, game) {
                            // Spawns 8 fire projectiles in a circle
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                game.bossProjectiles.push({
                                    x: boss.x,
                                    y: boss.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    size: 15,
                                    color: '#ff6600',
                                    damage: 1
                                });
                            }
                        }
                    },
                    {
                        name: 'Flame Breath',
                        cooldown: 5000,
                        execute: function(boss, game) {
                            // Shoots a stream of fire towards player
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const dx = game.player.x - boss.x;
                                    const dy = game.player.y - boss.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const spread = (Math.random() - 0.5) * 0.5;
                                    
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: (dx / dist) * 6 + spread,
                                        vy: (dy / dist) * 6 + spread,
                                        size: 12,
                                        color: '#ff9900',
                                        damage: 1
                                    });
                                }, i * 50);
                            }
                        }
                    },
                    {
                        name: 'Meteor Shower',
                        cooldown: 8000,
                        execute: function(boss, game) {
                            // Rains fire from above
                            for (let i = 0; i < 15; i++) {
                                setTimeout(() => {
                                    game.bossProjectiles.push({
                                        x: Math.random() * 720,
                                        y: -50,
                                        vx: 0,
                                        vy: 8,
                                        size: 20,
                                        color: '#ff0000',
                                        damage: 1
                                    });
                                }, i * 200);
                            }
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Sinusoidal horizontal movement
                    boss.x = 360 + Math.sin(time / 1000) * 250;
                    boss.y = 200 + Math.sin(time / 2000) * 50;
                }
            },
            
            // Boss 2: Void Kraken - Dark energy attacks
            void_kraken: {
                id: 'void_kraken',
                name: 'Void Kraken',
                hp: 1200,
                size: 160,
                color: '#9900ff',
                skills: [
                    {
                        name: 'Tentacle Slam',
                        cooldown: 4000,
                        execute: function(boss, game) {
                            // Creates shockwave lines
                            const targetX = game.player.x;
                            const targetY = game.player.y;
                            
                            for (let i = -2; i <= 2; i++) {
                                setTimeout(() => {
                                    game.bossProjectiles.push({
                                        x: boss.x + i * 80,
                                        y: boss.y,
                                        vx: 0,
                                        vy: 10,
                                        size: 40,
                                        color: '#cc00ff',
                                        damage: 1
                                    });
                                }, Math.abs(i) * 100);
                            }
                        }
                    },
                    {
                        name: 'Void Spiral',
                        cooldown: 6000,
                        execute: function(boss, game) {
                            // Spiral pattern of dark energy
                            let angle = 0;
                            for (let i = 0; i < 30; i++) {
                                setTimeout(() => {
                                    angle += 0.3;
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: Math.cos(angle) * 5,
                                        vy: Math.sin(angle) * 5,
                                        size: 12,
                                        color: '#ff00ff',
                                        damage: 1
                                    });
                                }, i * 80);
                            }
                        }
                    },
                    {
                        name: 'Dark Sphere',
                        cooldown: 7000,
                        execute: function(boss, game) {
                            // Homing dark orb
                            game.bossProjectiles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: 0,
                                vy: 2,
                                size: 30,
                                color: '#6600cc',
                                damage: 2,
                                homing: true,
                                speed: 3
                            });
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Figure-8 movement
                    const t = time / 2000;
                    boss.x = 360 + Math.sin(t) * 200;
                    boss.y = 250 + Math.sin(t * 2) * 100;
                }
            },
            
            // Boss 3: Cyber Skull - Laser and tech attacks
            cyber_skull: {
                id: 'cyber_skull',
                name: 'Cyber Skull',
                hp: 1500,
                size: 140,
                color: '#00ffff',
                skills: [
                    {
                        name: 'Laser Sweep',
                        cooldown: 5000,
                        execute: function(boss, game) {
                            // Rotating laser beam
                            boss.laserSweep = {
                                active: true,
                                angle: 0,
                                duration: 3000,
                                startTime: Date.now()
                            };
                        }
                    },
                    {
                        name: 'EMP Pulse',
                        cooldown: 6000,
                        execute: function(boss, game) {
                            // Expanding ring that slows player
                            game.bossProjectiles.push({
                                x: boss.x,
                                y: boss.y,
                                radius: 0,
                                maxRadius: 300,
                                expandSpeed: 5,
                                size: 5,
                                color: '#00ffff',
                                damage: 1,
                                ring: true
                            });
                        }
                    },
                    {
                        name: 'Missile Barrage',
                        cooldown: 7000,
                        execute: function(boss, game) {
                            // Rapid fire missiles
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    const angle = (i / 12) * Math.PI * 2;
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: Math.cos(angle) * 6,
                                        vy: Math.sin(angle) * 6,
                                        size: 10,
                                        color: '#00ff00',
                                        damage: 1
                                    });
                                }, i * 100);
                            }
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Circular orbit movement
                    const t = time / 3000;
                    boss.x = 360 + Math.cos(t) * 220;
                    boss.y = 300 + Math.sin(t) * 150;
                }
            }
        };

        // IMAGE OVERRIDE CONFIGURATION
        // Set image URLs here to use custom sprites, or leave as null to use default visuals
        const IMAGE_OVERRIDES = {
            playerShip: './img/spacecraft.png',       // Main player ship
            supportShip: './img/support-fighter.png',      // Support fighter ships
            laserFortressL1: null,  // Laser fortress level 1 turret
            laserFortressL2: null,  // Laser fortress level 2 turrets
            boss1: null,            // First boss type
            boss2: null,            // Second boss type
            boss3: null             // Third boss type
        };

        const game = {
            canvas: null,
            ctx: null,
            starLayers: [],
            loadedImages: {},  // Store loaded images

            state: {
                running: false,
                paused: false,
                score: 0,
                coins: 0,
                selectedSkill: null,
                gameTime: 0,
                lastBossSpawn: 0
            },

            player: {
                x: 360,
                y: 1100,
                width: 40,
                height: 60,
                speed: 8,
                hearts: 3,
                level: 1,
                xp: 0,
                xpToNext: 100,
                damage: 20,
                attackSpeed: 3,
                skills: {},
                lastShot: 0
            },

            bullets: [],
            asteroids: [],
            boss: null,
            bossProjectiles: [],
            keys: {},
            supportFighters: [],
            explosions: [],
            lightningBolts: [],
            missiles: [],
            laserShips: [],
            lastLightning: 0,
            lastMissile: 0,
            lastLaserActivation: 0,

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Make canvas responsive
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.initStarLayers();
                this.setupEventListeners();
                this.preloadImages();
                this.simulateLoading();
            },

            preloadImages() {
                // Preload all image overrides
                Object.keys(IMAGE_OVERRIDES).forEach(key => {
                    if (IMAGE_OVERRIDES[key]) {
                        const img = new Image();
                        img.onload = () => {
                            this.loadedImages[key] = img;
                        };
                        img.onerror = () => {
                            console.warn(`Failed to load image for ${key}, using default`);
                            this.loadedImages[key] = null;
                        };
                        img.src = IMAGE_OVERRIDES[key];
                    }
                });
            },

            resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Store scale for calculations
                this.scaleX = this.canvas.width / 720;
                this.scaleY = this.canvas.height / 1280;
            },

            initStarLayers() {
                this.starLayers = [
                    { stars: [], speed: 0.2, size: 1, count: 50, opacity: 0.4 },
                    { stars: [], speed: 0.5, size: 2, count: 80, opacity: 0.6 },
                    { stars: [], speed: 1.0, size: 3, count: 100, opacity: 0.9 }
                ];

                this.starLayers.forEach(layer => {
                    for (let i = 0; i < layer.count; i++) {
                        layer.stars.push({
                            x: Math.random() * 720,
                            y: Math.random() * 1280
                        });
                    }
                });
            },

            setupEventListeners() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // Touch controls
                const touchLayer = document.getElementById('touchLayer');
                touchLayer.width = 720;
                touchLayer.height = 1280;

                let touching = false;

                const getTouchPos = (e) => {
                    const rect = touchLayer.getBoundingClientRect();
                    const touch = e.touches[0];
                    return {
                        x: ((touch.clientX - rect.left) / rect.width) * 720,
                        y: ((touch.clientY - rect.top) / rect.height) * 1280
                    };
                };

                touchLayer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touching = true;
                    if (this.state.running && !this.state.paused) {
                        const pos = getTouchPos(e);
                        this.player.x = Math.max(30, Math.min(690, pos.x));
                        this.player.y = Math.max(30, Math.min(1250, pos.y));
                    }
                });

                touchLayer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (touching && this.state.running && !this.state.paused) {
                        const pos = getTouchPos(e);
                        this.player.x = Math.max(30, Math.min(690, pos.x));
                        this.player.y = Math.max(30, Math.min(1250, pos.y));
                    }
                });

                touchLayer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touching = false;
                });

                touchLayer.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    touching = false;
                });
            },

            simulateLoading() {
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    this.showMainMenu();
                }, 3000);
            },

            showMainMenu() {
                document.getElementById('mainMenu').classList.add('active');
            },

            startGame() {
                document.getElementById('mainMenu').classList.remove('active');
                
                this.state = {
                    running: true,
                    paused: false,
                    score: 0,
                    coins: 0,
                    selectedSkill: null,
                    gameTime: 0,
                    lastBossSpawn: 0
                };

                this.player = {
                    x: 360,
                    y: 1100,
                    width: 40,
                    height: 60,
                    speed: 8,
                    hearts: 3,
                    level: 1,
                    xp: 0,
                    xpToNext: 100,
                    damage: 20,
                    attackSpeed: 3,
                    skills: {},
                    lastShot: 0
                };

                this.bullets = [];
                this.asteroids = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.supportFighters = [];
                this.explosions = [];
                this.lightningBolts = [];
                this.missiles = [];
                this.laserShips = [];
                this.lastLightning = 0;
                this.lastMissile = 0;
                this.lastLaserActivation = 0;

                this.updateHUD();
                document.getElementById('touchLayer').classList.add('active');
                document.getElementById('pauseBtn').classList.add('active');
                this.gameLoop();
            },

            togglePause() {
                this.state.paused = !this.state.paused;
                const pauseMenu = document.getElementById('pauseMenu');
                if (this.state.paused) {
                    pauseMenu.classList.add('active');
                } else {
                    pauseMenu.classList.remove('active');
                }
            },

            resumeGame() {
                this.state.paused = false;
                document.getElementById('pauseMenu').classList.remove('active');
            },

            returnToMainMenu() {
                this.state.paused = false;
                this.state.running = false;
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('touchLayer').classList.remove('active');
                document.getElementById('pauseBtn').classList.remove('active');
                this.showMainMenu();
            },

            showHelp() {
                document.getElementById('helpScreen').classList.add('active');
            },

            closeHelp() {
                document.getElementById('helpScreen').classList.remove('active');
            },

            updateHUD() {
                const heartsContainer = document.getElementById('hearts');
                heartsContainer.innerHTML = '';
                for (let i = 0; i < this.player.hearts; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    heartsContainer.appendChild(heart);
                }

                document.getElementById('levelNum').textContent = this.player.level;
                const xpPercent = (this.player.xp / this.player.xpToNext) * 100;
                document.getElementById('xpFill').style.width = xpPercent + '%';

                document.getElementById('scoreDisplay').textContent = this.state.score;
                document.getElementById('coinDisplay').textContent = this.state.coins;
            },

            gainXP(amount) {
                this.player.xp += amount;
                if (this.player.xp >= this.player.xpToNext) {
                    this.levelUp();
                }
                this.updateHUD();
            },

            levelUp() {
                this.player.level++;
                this.player.xp = 0;
                this.player.xpToNext = Math.floor(this.player.xpToNext * 1.5);
                this.state.paused = true;
                this.showSkillSelection();
            },

            showSkillSelection() {
                const container = document.getElementById('skillsContainer');
                container.innerHTML = '';

                const available = Object.values(SKILLS).filter(skill => {
                    const currentTier = this.player.skills[skill.id] || 0;
                    if (currentTier >= skill.maxTier) return false;
                    
                    for (let conflict of skill.conflicts) {
                        if (this.player.skills[conflict] > 0) return false;
                    }
                    return true;
                });

                const choices = [];
                const pool = [...available];
                while (choices.length < 3 && pool.length > 0) {
                    const idx = Math.floor(Math.random() * pool.length);
                    choices.push(pool[idx]);
                    pool.splice(idx, 1);
                }

                choices.forEach(skill => {
                    const currentTier = this.player.skills[skill.id] || 0;
                    const nextTier = currentTier + 1;

                    const card = document.createElement('div');
                    card.className = 'skill-card';
                    card.innerHTML = `
                        <div class="skill-icon">${skill.icon}</div>
                        <div class="skill-name">${skill.name}</div>
                        <div class="skill-description">${skill.description}<br>Tier ${nextTier}/${skill.maxTier}</div>
                    `;
                    card.onclick = () => this.selectSkill(skill, nextTier, card);
                    container.appendChild(card);
                });

                document.getElementById('skillScreen').classList.add('active');
            },

            selectSkill(skill, tier, cardElement) {
                document.querySelectorAll('.skill-card').forEach(c => c.classList.remove('selected'));
                cardElement.classList.add('selected');
                this.state.selectedSkill = { id: skill.id, tier: tier };
                document.getElementById('confirmSkill').disabled = false;
            },

            confirmSkill() {
                if (!this.state.selectedSkill) return;

                const { id, tier } = this.state.selectedSkill;
                this.player.skills[id] = tier;

                if (id === 'support_fighters') {
                    this.initSupportFighters(tier);
                }
                if (id === 'laser_fortress') {
                    this.initLaserShips(tier);
                }

                document.getElementById('skillScreen').classList.remove('active');
                this.state.paused = false;
                this.updateHUD();
            },

            initSupportFighters(tier) {
                this.supportFighters = [];
                this.supportFighters.push({
                    offsetX: -60,
                    offsetY: -20,
                    lastShot: 0
                });
                this.supportFighters.push({
                    offsetX: 60,
                    offsetY: -20,
                    lastShot: 0
                });
            },

            initLaserShips(tier) {
                this.laserShips = [];
                if (tier === 1) {
                    // Level 1: 1 turret on left edge
                    this.laserShips.push({
                        x: 30,
                        y: 400,
                        active: false,
                        activationTime: 0
                    });
                } else {
                    // Level 2: 2 turrets on right edge, remove left turret
                    this.laserShips.push({
                        x: 690,
                        y: 300,
                        active: false,
                        activationTime: 0
                    });
                    this.laserShips.push({
                        x: 690,
                        y: 500,
                        active: false,
                        activationTime: 0
                    });
                }
            },

            spawnBoss() {
                const bossTypes = Object.values(BOSSES);
                const selectedBoss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                
                // Boss HP scales moderately with time (every 180 seconds = 1 boss cycle adds 20% HP)
                const bossCount = Math.floor(this.state.gameTime / 180);
                const hpScaling = 1 + (bossCount * 0.2); // 20% increase per boss cycle
                
                this.boss = {
                    ...selectedBoss,
                    x: 360,
                    y: 200,
                    currentHp: Math.floor(selectedBoss.hp * hpScaling),
                    maxHp: Math.floor(selectedBoss.hp * hpScaling),
                    skillCooldowns: selectedBoss.skills.map(() => 0),
                    laserSweep: null,
                    spawnTime: Date.now()
                };

                // Show boss warning
                const warning = document.getElementById('bossWarning');
                warning.classList.add('active');
                setTimeout(() => {
                    warning.classList.remove('active');
                }, 3000);

                this.state.lastBossSpawn = this.state.gameTime;
            },

            gameLoop() {
                if (!this.state.running) return;
                
                if (!this.state.paused) {
                    this.update();
                    this.state.gameTime += 1/60;
                }
                
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            },

            update() {
                // Keyboard movement
                if (this.keys['ArrowLeft'] || this.keys['a']) this.player.x -= this.player.speed;
                if (this.keys['ArrowRight'] || this.keys['d']) this.player.x += this.player.speed;
                if (this.keys['ArrowUp'] || this.keys['w']) this.player.y -= this.player.speed;
                if (this.keys['ArrowDown'] || this.keys['s']) this.player.y += this.player.speed;
                
                this.player.x = Math.max(30, Math.min(690, this.player.x));
                this.player.y = Math.max(30, Math.min(1250, this.player.y));

                // Boss spawning (every 3 minutes = 180 seconds)
                if (!this.boss && this.state.gameTime - this.state.lastBossSpawn >= 180) {
                    this.spawnBoss();
                }

                // Update boss countdown timer
                const bossTimerEl = document.getElementById('bossTimer');
                const bossTimerText = document.getElementById('bossTimerText');
                if (!this.boss) {
                    const timeUntilBoss = 180 - (this.state.gameTime - this.state.lastBossSpawn);
                    if (timeUntilBoss > 0) {
                        bossTimerEl.style.display = 'block';
                        const minutes = Math.floor(timeUntilBoss / 60);
                        const seconds = Math.floor(timeUntilBoss % 60);
                        bossTimerText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        bossTimerEl.style.display = 'none';
                    }
                } else {
                    bossTimerEl.style.display = 'none';
                }

                // Shooting
                const now = Date.now();
                const tier = this.player.skills.support_fighters || 0;
                const mainShipFires = tier !== 1;

                if (mainShipFires && now - this.player.lastShot > 1000 / this.player.attackSpeed) {
                    this.shoot();
                    this.player.lastShot = now;
                }

                // Support fighters
                if (tier > 0) {
                    this.supportFighters.forEach(fighter => {
                        // Support fighters now fire at same rate as main ship
                        if (now - fighter.lastShot > 1000 / this.player.attackSpeed) {
                            const dmg = tier === 2 ? this.player.damage * 1.5 : this.player.damage;
                            this.bullets.push({
                                x: this.player.x + fighter.offsetX,
                                y: this.player.y + fighter.offsetY,
                                width: 6,
                                height: 16,
                                damage: dmg,
                                fromFighter: true
                            });
                            fighter.lastShot = now;
                        }
                    });
                }

                // Chain Lightning
                const lightningTier = this.player.skills.chain_lightning || 0;
                if (lightningTier > 0) {
                    const cooldown = lightningTier === 1 ? 8000 : 5000;
                    if (now - this.lastLightning > cooldown) {
                        this.activateChainLightning(lightningTier);
                        this.lastLightning = now;
                    }
                }

                // Homing Missiles
                const missileTier = this.player.skills.homing_missiles || 0;
                if (missileTier > 0) {
                    if (now - this.lastMissile > 3000) {
                        this.launchMissiles(missileTier);
                        this.lastMissile = now;
                    }
                }

                // Laser Fortress
                const laserTier = this.player.skills.laser_fortress || 0;
                if (laserTier > 0) {
                    const cooldown = laserTier === 1 ? 15000 : 10000;
                    const duration = 10000;

                    this.laserShips.forEach(ship => {
                        if (!ship.active && now - this.lastLaserActivation > cooldown) {
                            ship.active = true;
                            ship.activationTime = now;
                            this.lastLaserActivation = now;
                        }

                        if (ship.active && now - ship.activationTime > duration) {
                            ship.active = false;
                        }

                        if (ship.active) {
                            this.applyLaserDamage(ship, laserTier);
                        }
                    });
                }

                // Update boss
                if (this.boss) {
                    const bossTime = now - this.boss.spawnTime;
                    this.boss.movement(this.boss, this, bossTime);

                    // Boss skills
                    this.boss.skills.forEach((skill, idx) => {
                        if (now - this.boss.skillCooldowns[idx] > skill.cooldown) {
                            skill.execute(this.boss, this);
                            this.boss.skillCooldowns[idx] = now;
                        }
                    });

                    // Laser sweep for Cyber Skull
                    if (this.boss.laserSweep && this.boss.laserSweep.active) {
                        const elapsed = now - this.boss.laserSweep.startTime;
                        if (elapsed > this.boss.laserSweep.duration) {
                            this.boss.laserSweep.active = false;
                        } else {
                            this.boss.laserSweep.angle += 0.05;
                        }
                    }
                }

                // Update boss projectiles
                this.bossProjectiles.forEach((proj, idx) => {
                    if (proj.homing) {
                        const dx = this.player.x - proj.x;
                        const dy = this.player.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        proj.vx += (dx / dist) * 0.2;
                        proj.vy += (dy / dist) * 0.2;
                        const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
                        if (speed > proj.speed) {
                            proj.vx = (proj.vx / speed) * proj.speed;
                            proj.vy = (proj.vy / speed) * proj.speed;
                        }
                    }

                    if (proj.ring) {
                        proj.radius += proj.expandSpeed;
                        if (proj.radius > proj.maxRadius) {
                            this.bossProjectiles.splice(idx, 1);
                            return;
                        }
                    } else {
                        proj.x += proj.vx;
                        proj.y += proj.vy;
                    }

                    // Check collision with player
                    if (proj.ring) {
                        const dist = Math.sqrt((this.player.x - proj.x) ** 2 + (this.player.y - proj.y) ** 2);
                        if (Math.abs(dist - proj.radius) < 20) {
                            this.player.hearts -= proj.damage;
                            this.updateHUD();
                            if (this.player.hearts <= 0) this.gameOver();
                        }
                    } else if (this.checkCollision(this.player, proj)) {
                        this.player.hearts -= proj.damage;
                        this.updateHUD();
                        this.bossProjectiles.splice(idx, 1);
                        if (this.player.hearts <= 0) this.gameOver();
                    }

                    if (proj.x < -50 || proj.x > 770 || proj.y < -50 || proj.y > 1330) {
                        this.bossProjectiles.splice(idx, 1);
                    }
                });

                // Spawn asteroids (INCREASED SIZE)
                const baseSpawnRate = 0.008;
                const maxSpawnRate = 0.025;
                const spawnRateIncrease = Math.min(this.state.gameTime / 120, 1);
                const currentSpawnRate = baseSpawnRate + (maxSpawnRate - baseSpawnRate) * spawnRateIncrease;
                
                if (Math.random() < currentSpawnRate) {
                    this.spawnAsteroid();
                }

                // Update bullets
                this.bullets = this.bullets.filter(b => {
                    b.y -= 15;
                    
                    if (b.ricochet && b.bounced) {
                        b.x += b.vx || 0;
                        b.y += b.vy || 0;
                    }
                    
                    return b.y > -20 && b.y < 1300 && b.x > 0 && b.x < 720;
                });

                // Update missiles
                this.missiles.forEach(missile => {
                    let target = missile.target;
                    if (this.boss && (!target || !this.asteroids.includes(target))) {
                        target = this.boss;
                    }
                    
                    if (target && (this.asteroids.includes(target) || target === this.boss)) {
                        const dx = target.x - missile.x;
                        const dy = target.y - missile.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Increased tracking strength from 0.3 to 0.5
                        missile.vx += (dx / dist) * 0.5;
                        missile.vy += (dy / dist) * 0.5;
                        
                        const speed = Math.sqrt(missile.vx * missile.vx + missile.vy * missile.vy);
                        // Increased max speed from 6 to 9
                        if (speed > 9) {
                            missile.vx = (missile.vx / speed) * 9;
                            missile.vy = (missile.vy / speed) * 9;
                        }
                    }
                    
                    missile.x += missile.vx;
                    missile.y += missile.vy;
                });

                // Update asteroids
                this.asteroids.forEach((a, i) => {
                    if (a.knockbackTime !== undefined) {
                        a.knockbackTime--;
                        if (a.knockbackTime <= 0) {
                            delete a.knockbackTime;
                            delete a.knockbackVx;
                            delete a.knockbackVy;
                        } else {
                            a.x += a.knockbackVx;
                            a.y += a.knockbackVy;
                        }
                    } else {
                        a.y += a.vy;
                        a.x += a.vx;
                    }
                    
                    a.rotation += a.rotSpeed;

                    if (a.x <= a.size/2 || a.x >= 720 - a.size/2) a.vx *= -1;

                    if (this.checkCollision(this.player, a)) {
                        this.player.hearts--;
                        this.updateHUD();
                        this.asteroids.splice(i, 1);
                        if (this.player.hearts <= 0) this.gameOver();
                    }

                    if (a.y > 1300) this.asteroids.splice(i, 1);
                });

                // Bullet-asteroid/boss collisions
                this.bullets.forEach((b, bi) => {
                    let hitCount = 0;
                    const pierceTier = this.player.skills.piercing_bullets || 0;
                    const maxPierce = pierceTier === 1 ? 2 : (pierceTier === 2 ? 4 : 1);
                    
                    // Check boss collision
                    if (this.boss && this.checkCollision(b, this.boss) && hitCount < maxPierce) {
                        const dmg = b.damage || this.player.damage;
                        const finalDmg = pierceTier === 2 && hitCount === 0 ? dmg * 2 : dmg;
                        
                        this.boss.currentHp -= finalDmg;
                        hitCount++;
                        
                        const explosiveTier = this.player.skills.explosive_bullets || 0;
                        if (explosiveTier > 0) {
                            this.createExplosion(b.x, b.y, explosiveTier);
                        }
                        
                        if (this.boss.currentHp <= 0) {
                            this.gainXP(500);
                            this.state.score += 1000;
                            this.state.coins += 50;
                            this.boss = null;
                            this.updateHUD();
                        }
                        
                        if (pierceTier === 0) {
                            this.bullets.splice(bi, 1);
                        }
                    }
                    
                    // Check asteroid collisions
                    this.asteroids.forEach((a, ai) => {
                        if (this.checkCollision(b, a) && hitCount < maxPierce) {
                            const dmg = b.damage || this.player.damage;
                            const finalDmg = pierceTier === 2 && hitCount === 0 ? dmg * 2 : dmg;
                            
                            a.hp -= finalDmg;
                            hitCount++;
                            
                            const explosiveTier = this.player.skills.explosive_bullets || 0;
                            if (explosiveTier > 0) {
                                this.createExplosion(b.x, b.y, explosiveTier);
                            }
                            
                            const ricochetTier = this.player.skills.ricochet_bullets || 0;
                            if (ricochetTier > 0 && !b.bounced) {
                                if (ricochetTier === 1) {
                                    b.bounced = true;
                                    const angle = Math.random() * Math.PI * 2;
                                    b.vx = Math.cos(angle) * 10;
                                    b.vy = Math.sin(angle) * 10;
                                    b.ricochet = true;
                                } else {
                                    for (let i = 0; i < 2; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        this.bullets.push({
                                            x: b.x,
                                            y: b.y,
                                            width: 6,
                                            height: 16,
                                            damage: dmg,
                                            vx: Math.cos(angle) * 8,
                                            vy: Math.sin(angle) * 8,
                                            bounced: true,
                                            ricochet: true
                                        });
                                    }
                                }
                            }
                            
                            if (a.hp <= 0) {
                                const rewards = this.getRewardsForAsteroid(a.tier);
                                this.destroyAsteroid(a, ai);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                            
                            if (pierceTier === 0 && ricochetTier === 0) {
                                this.bullets.splice(bi, 1);
                            }
                        }
                    });
                });

                // Missile collisions
                this.missiles.forEach((m, mi) => {
                    if (this.boss && this.checkCollision(m, this.boss)) {
                        this.boss.currentHp -= this.player.damage * 1.5;
                        
                        if (this.boss.currentHp <= 0) {
                            this.gainXP(500);
                            this.state.score += 1000;
                            this.state.coins += 50;
                            this.boss = null;
                            this.updateHUD();
                        }
                        
                        this.missiles.splice(mi, 1);
                        return;
                    }
                    
                    this.asteroids.forEach((a, ai) => {
                        if (this.checkCollision(m, a)) {
                            a.hp -= this.player.damage * 1.5;
                            
                            if (a.hp <= 0) {
                                const rewards = this.getRewardsForAsteroid(a.tier);
                                this.destroyAsteroid(a, ai);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                            
                            this.missiles.splice(mi, 1);
                        }
                    });
                });

                // Update explosions
                this.explosions = this.explosions.filter(exp => {
                    exp.time += 16;
                    return exp.time < exp.duration;
                });

                // Update lightning
                this.lightningBolts = this.lightningBolts.filter(bolt => {
                    bolt.time += 16;
                    return bolt.time < bolt.duration;
                });
            },

            activateChainLightning(tier) {
                const chainCount = tier === 1 ? 3 : 5;
                const damage = tier === 1 ? this.player.damage * 1.5 : this.player.damage * 1.75;
                const color = tier === 1 ? '#00ffff' : '#ff0066';
                
                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                targets = targets.sort((a, b) => {
                    const distA = Math.sqrt((a.x - this.player.x) ** 2 + (a.y - this.player.y) ** 2);
                    const distB = Math.sqrt((b.x - this.player.x) ** 2 + (b.y - this.player.y) ** 2);
                    return distA - distB;
                }).slice(0, chainCount);

                let prev = { x: this.player.x, y: this.player.y };
                targets.forEach(target => {
                    this.lightningBolts.push({
                        x1: prev.x,
                        y1: prev.y,
                        x2: target.x,
                        y2: target.y,
                        color: color,
                        time: 0,
                        duration: 500
                    });
                    
                    if (target === this.boss) {
                        this.boss.currentHp -= damage;
                        if (this.boss.currentHp <= 0) {
                            this.gainXP(500);
                            this.state.score += 1000;
                            this.state.coins += 50;
                            this.boss = null;
                            this.updateHUD();
                        }
                    } else {
                        target.hp -= damage;
                        if (target.hp <= 0) {
                            const idx = this.asteroids.indexOf(target);
                            if (idx !== -1) {
                                const rewards = this.getRewardsForAsteroid(target.tier);
                                this.destroyAsteroid(target, idx);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                        }
                    }
                    
                    prev = target;
                });
            },

            launchMissiles(tier) {
                const count = tier === 1 ? 1 : 3;
                let targets = [...this.asteroids];
                if (this.boss) targets = [this.boss, ...targets];
                
                targets = targets.sort((a, b) => {
                    const distA = Math.sqrt((a.x - this.player.x) ** 2 + (a.y - this.player.y) ** 2);
                    const distB = Math.sqrt((b.x - this.player.x) ** 2 + (b.y - this.player.y) ** 2);
                    return distA - distB;
                }).slice(0, count);

                targets.forEach(target => {
                    this.missiles.push({
                        x: this.player.x,
                        y: this.player.y - 30,
                        vx: 0,
                        vy: -3,
                        target: target,
                        size: 8
                    });
                });
            },

            applyLaserDamage(ship, tier) {
                const damage = tier === 1 ? 5 : 7.5;
                const laserY = ship.y;
                const laserThickness = 15;

                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                targets.forEach((target, idx) => {
                    // Check if target is within the horizontal beam's vertical range
                    const targetSize = target.size || target.width || 50;
                    const verticalDist = Math.abs(target.y - laserY);
                    
                    if (verticalDist < laserThickness / 2 + targetSize / 2) {
                        // Check if target is in the beam's horizontal path
                        let inBeamPath = false;
                        if (tier === 1) {
                            // Left turret fires to the right
                            inBeamPath = target.x >= ship.x;
                        } else {
                            // Right turret fires to the left
                            inBeamPath = target.x <= ship.x;
                        }

                        if (inBeamPath) {
                            // Check if blocked by another entity
                            const blocked = this.isHorizontalLaserBlocked(ship, target, tier);
                            
                            if (!blocked && Math.random() < 0.05) {
                                if (target === this.boss) {
                                    this.boss.currentHp -= damage;
                                    if (this.boss.currentHp <= 0) {
                                        this.gainXP(500);
                                        this.state.score += 1000;
                                        this.state.coins += 50;
                                        this.boss = null;
                                        this.updateHUD();
                                    }
                                } else {
                                    target.hp -= damage;
                                    if (target.hp <= 0) {
                                        const rewards = this.getRewardsForAsteroid(target.tier);
                                        this.destroyAsteroid(target, idx);
                                        this.gainXP(10);
                                        this.state.score += rewards.stars;
                                        this.state.coins += rewards.coins;
                                        this.updateHUD();
                                    }
                                }
                            }
                        }
                    }
                });
            },

            isHorizontalLaserBlocked(ship, targetEntity, tier) {
                // Check if any entity blocks the horizontal laser path
                let entities = [...this.asteroids];
                if (this.boss && this.boss !== targetEntity) entities.push(this.boss);
                
                const laserY = ship.y;
                const laserThickness = 15;
                
                for (let entity of entities) {
                    if (entity === targetEntity) continue;
                    
                    const entitySize = entity.size || entity.width || 50;
                    const verticalDist = Math.abs(entity.y - laserY);
                    
                    // Check if blocking entity is in the vertical range of the beam
                    if (verticalDist < laserThickness / 2 + entitySize / 2) {
                        // Check if blocking entity is between turret and target
                        if (tier === 1) {
                            // Left turret: blocker must be between turret and target
                            if (entity.x > ship.x && entity.x < targetEntity.x) {
                                return true;
                            }
                        } else {
                            // Right turret: blocker must be between target and turret
                            if (entity.x < ship.x && entity.x > targetEntity.x) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            },

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                const param = lenSq !== 0 ? dot / lenSq : -1;
                
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },

            createExplosion(x, y, tier) {
                const radius = tier === 1 ? 50 : 80;
                const damage = tier === 1 ? this.player.damage : this.player.damage * 2;
                
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: radius,
                    maxRadius: tier === 1 ? 60 : 100,
                    time: 0,
                    duration: tier === 1 ? 300 : 400
                });
                
                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                targets.forEach((target, idx) => {
                    const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
                    if (dist < radius) {
                        if (target === this.boss) {
                            this.boss.currentHp -= damage;
                            if (this.boss.currentHp <= 0) {
                                this.gainXP(500);
                                this.state.score += 1000;
                                this.state.coins += 50;
                                this.boss = null;
                                this.updateHUD();
                            }
                        } else {
                            target.hp -= damage;
                            if (target.hp <= 0) {
                                const rewards = this.getRewardsForAsteroid(target.tier);
                                this.destroyAsteroid(target, idx);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                        }
                    }
                });
            },

            destroyAsteroid(asteroid, index) {
                this.asteroids.splice(index, 1);

                if (asteroid.tier !== 'small') {
                    const nextTier = this.getNextTier(asteroid.tier);
                    const nextSize = this.getSizeForTier(nextTier);
                    const nextHP = this.getHPForTier(nextTier);

                    for (let i = 0; i < 2; i++) {
                        const horizontalDirection = (i === 0 ? -1 : 1);
                        const horizontalSpeed = 2 + Math.random() * 1.5;
                        const baseDownwardVelocity = Math.max(asteroid.vy, 1.5);
                        const downwardSpeed = baseDownwardVelocity + Math.random() * 0.5;

                        this.asteroids.push({
                            x: asteroid.x + horizontalDirection * 20,
                            y: asteroid.y,
                            size: nextSize,
                            hp: nextHP,
                            tier: nextTier,
                            vx: horizontalDirection * horizontalSpeed,
                            vy: downwardSpeed,
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.08,
                            color: asteroid.color,
                            vertices: this.generatePolygon(nextSize)
                        });
                    }
                }
            },

            getNextTier(currentTier) {
                const tiers = {
                    'veryLarge': 'large',
                    'large': 'medium',
                    'medium': 'small',
                    'small': null
                };
                return tiers[currentTier];
            },

            getSizeForTier(tier) {
                // INCREASED SIZE (multiplied by 1.5)
                const sizes = {
                    'veryLarge': 180,
                    'large': 127,
                    'medium': 82,
                    'small': 45
                };
                return sizes[tier];
            },

            getHPForTier(tier) {
                const baseHPs = {
                    'veryLarge': 80,
                    'large': 40,
                    'medium': 20,
                    'small': 10
                };
                
                // HP scales up gradually with game time (every 60 seconds increases HP by 10%)
                const timeBonus = Math.floor(this.state.gameTime / 60) * 0.1;
                const scalingFactor = 1 + timeBonus;
                
                return Math.floor(baseHPs[tier] * scalingFactor);
            },

            getRewardsForAsteroid(tier) {
                const maxHP = this.getHPForTier(tier);
                return {
                    coins: Math.floor(maxHP * 0.1), // 10% of HP
                    stars: Math.floor(maxHP * 0.01) || 1 // 1% of HP, minimum 1
                };
            },

            shoot() {
                this.bullets.push({
                    x: this.player.x,
                    y: this.player.y - 30,
                    width: 8,
                    height: 20,
                    damage: this.player.damage
                });
            },

            spawnAsteroid() {
                const tierWeights = [
                    { tier: 'veryLarge', weight: 0.3 },
                    { tier: 'large', weight: 0.35 },
                    { tier: 'medium', weight: 0.25 },
                    { tier: 'small', weight: 0.1 }
                ];

                let rand = Math.random();
                let selectedTier = 'medium';
                let cumulative = 0;
                
                for (const tw of tierWeights) {
                    cumulative += tw.weight;
                    if (rand <= cumulative) {
                        selectedTier = tw.tier;
                        break;
                    }
                }

                const size = this.getSizeForTier(selectedTier);
                const hp = this.getHPForTier(selectedTier);
                const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ff8800', '#8800ff', '#ffff00', '#ff0088', '#00ff88'];

                this.asteroids.push({
                    x: Math.random() * 720,
                    y: -100,
                    size: size,
                    hp: hp,
                    tier: selectedTier,
                    vx: (Math.random() - 0.5) * 2,
                    vy: 1 + Math.random() * 2,
                    rotation: 0,
                    rotSpeed: (Math.random() - 0.5) * 0.05,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    vertices: this.generatePolygon(size)
                });
            },

            generatePolygon(size) {
                const vertices = [];
                const count = 6 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = size / 2 * (0.8 + Math.random() * 0.4);
                    vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                return vertices;
            },

            checkCollision(a, b) {
                const r1 = a.width ? Math.max(a.width, a.height) / 2 : (a.size || 5);
                const r2 = b.width ? Math.max(b.width, b.height) / 2 : (b.size ? b.size / 2 : 5);
                const dist = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
                return dist < r1 + r2;
            },

            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.renderParallaxStars();

                // Render horizontal laser beams (FIXED - no auto-targeting)
                this.laserShips.forEach(ship => {
                    if (ship.active) {
                        const laserY = ship.y;
                        const beamThickness = 15;
                        const tier = this.player.skills.laser_fortress || 0;
                        
                        if (tier === 2) {
                            // Level 2: Red beam with white borders, fires to the left
                            // White borders
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = beamThickness + 6;
                            this.ctx.globalAlpha = 0.6;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#ffffff';
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, laserY);
                            this.ctx.lineTo(ship.x, laserY);
                            this.ctx.stroke();
                            
                            // Red main beam
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.lineWidth = beamThickness;
                            this.ctx.shadowColor = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, laserY);
                            this.ctx.lineTo(ship.x, laserY);
                            this.ctx.stroke();
                        } else {
                            // Level 1: Standard red beam, fires to the right
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.lineWidth = beamThickness;
                            this.ctx.globalAlpha = 0.6;
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.moveTo(ship.x, laserY);
                            this.ctx.lineTo(this.canvas.width, laserY);
                            this.ctx.stroke();
                        }
                        
                        this.ctx.globalAlpha = 1;
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Render laser turrets with image override support
                this.laserShips.forEach(ship => {
                    const tier = this.player.skills.laser_fortress || 0;
                    const imageKey = tier === 1 ? 'laserFortressL1' : 'laserFortressL2';
                    const img = this.loadedImages[imageKey];
                    
                    if (img) {
                        // Use custom image
                        this.ctx.save();
                        this.ctx.translate(ship.x, ship.y);
                        this.ctx.drawImage(img, -20, -20, 40, 40);
                        this.ctx.restore();
                    } else {
                        // Default visual
                        this.ctx.fillStyle = ship.active ? '#ff0000' : '#666';
                        this.ctx.shadowBlur = ship.active ? 15 : 0;
                        this.ctx.shadowColor = '#ff0000';
                        this.ctx.fillRect(ship.x - 20, ship.y - 20, 40, 40);
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Render boss laser sweep
                if (this.boss && this.boss.laserSweep && this.boss.laserSweep.active) {
                    const angle = this.boss.laserSweep.angle;
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 10;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.boss.x, this.boss.y);
                    this.ctx.lineTo(
                        this.boss.x + Math.cos(angle) * 1000,
                        this.boss.y + Math.sin(angle) * 1000
                    );
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }

                // Render boss projectiles
                this.bossProjectiles.forEach(proj => {
                    if (proj.ring) {
                        this.ctx.strokeStyle = proj.color;
                        this.ctx.lineWidth = 5;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = proj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                    } else {
                        this.ctx.fillStyle = proj.color;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = proj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Render boss with image override support
                if (this.boss) {
                    // Check for custom boss image
                    const bossImageKey = `boss${['flame_demon', 'void_kraken', 'cyber_skull'].indexOf(this.boss.id) + 1}`;
                    const bossImg = this.loadedImages[bossImageKey];
                    
                    this.ctx.save();
                    this.ctx.translate(this.boss.x, this.boss.y);
                    
                    if (bossImg) {
                        // Use custom image for boss
                        const size = this.boss.size * 2;
                        this.ctx.drawImage(bossImg, -size/2, -size/2, size, size);
                    } else {
                        // Draw boss based on type (default visuals)
                        if (this.boss.id === 'flame_demon') {
                            // Flame demon - skull shape
                            this.ctx.fillStyle = this.boss.color;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            this.ctx.beginPath();
                            this.ctx.arc(0, -20, 50, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.fillRect(-30, 10, 60, 40);
                            
                            // Eyes
                            this.ctx.fillStyle = '#000';
                            this.ctx.beginPath();
                            this.ctx.arc(-20, -20, 10, 0, Math.PI * 2);
                            this.ctx.arc(20, -20, 10, 0, Math.PI * 2);
                            this.ctx.fill();
                        } else if (this.boss.id === 'void_kraken') {
                            // Void kraken - tentacle creature
                            this.ctx.fillStyle = this.boss.color;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 60, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Tentacles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                this.ctx.beginPath();
                                this.ctx.moveTo(0, 0);
                                this.ctx.lineTo(Math.cos(angle) * 80, Math.sin(angle) * 80);
                                this.ctx.lineWidth = 15;
                                this.ctx.strokeStyle = this.boss.color;
                                this.ctx.stroke();
                            }
                        } else if (this.boss.id === 'cyber_skull') {
                            // Cyber skull - geometric
                            this.ctx.strokeStyle = this.boss.color;
                            this.ctx.fillStyle = this.boss.color + '44';
                            this.ctx.lineWidth = 4;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            
                            // Hexagon
                            this.ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const x = Math.cos(angle) * 60;
                                const y = Math.sin(angle) * 60;
                                if (i === 0) this.ctx.moveTo(x, y);
                                else this.ctx.lineTo(x, y);
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // Inner circle
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 30, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                    
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                    
                    // HP bar
                    const barWidth = 150;
                    const barHeight = 10;
                    const hpPercent = this.boss.currentHp / this.boss.maxHp;
                    
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(this.boss.x - barWidth/2, this.boss.y - this.boss.size - 20, barWidth, barHeight);
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fillRect(this.boss.x - barWidth/2, this.boss.y - this.boss.size - 20, barWidth * hpPercent, barHeight);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(this.boss.x - barWidth/2, this.boss.y - this.boss.size - 20, barWidth, barHeight);
                    
                    // Boss name
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.boss.name, this.boss.x, this.boss.y - this.boss.size - 35);
                }

                // Render asteroids
                this.asteroids.forEach(a => {
                    this.ctx.save();
                    this.ctx.translate(a.x, a.y);
                    this.ctx.rotate(a.rotation);
                    this.ctx.beginPath();
                    a.vertices.forEach((v, i) => {
                        if (i === 0) this.ctx.moveTo(v.x, v.y);
                        else this.ctx.lineTo(v.x, v.y);
                    });
                    this.ctx.closePath();
                    this.ctx.fillStyle = a.color + '33';
                    this.ctx.fill();
                    this.ctx.strokeStyle = a.color;
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = a.color;
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = `bold ${a.size * 0.3}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(Math.ceil(a.hp), a.x, a.y);
                });

                // Render player with image override support
                const playerImg = this.loadedImages['playerShip'];
                this.ctx.save();
                this.ctx.translate(this.player.x, this.player.y);
                
                if (playerImg) {
                    // Use custom image
                    this.ctx.drawImage(playerImg, -30, -45, 60, 90);
                } else {
                    // Default visual
                    this.ctx.fillStyle = '#fff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -30);
                    this.ctx.lineTo(-20, 30);
                    this.ctx.lineTo(0, 20);
                    this.ctx.lineTo(20, 30);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.restore();

                // Render support fighters with image override support
                const supportImg = this.loadedImages['supportShip'];
                this.supportFighters.forEach(fighter => {
                    const x = this.player.x + fighter.offsetX;
                    const y = this.player.y + fighter.offsetY;
                    this.ctx.save();
                    this.ctx.translate(x, y);
                    
                    if (supportImg) {
                        // Use custom image
                        this.ctx.drawImage(supportImg, -15, -22.5, 30, 45);
                    } else {
                        // Default visual
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -15);
                        this.ctx.lineTo(-10, 15);
                        this.ctx.lineTo(0, 10);
                        this.ctx.lineTo(10, 15);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.restore();
                });

                // Render bullets
                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.fromFighter ? '#00ffff' : '#00ff00';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = b.fromFighter ? '#00ffff' : '#00ff00';
                    this.ctx.fillRect(b.x - 4, b.y - 10, 8, 20);
                    this.ctx.shadowBlur = 0;
                });

                // Render missiles
                this.missiles.forEach(m => {
                    this.ctx.save();
                    this.ctx.translate(m.x, m.y);
                    
                    // Calculate angle based on velocity
                    const angle = Math.atan2(m.vy, m.vx) + Math.PI / 2;
                    this.ctx.rotate(angle);
                    
                    // Red bottom triangle
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -12);
                    this.ctx.lineTo(-8, 8);
                    this.ctx.lineTo(8, 8);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // White top triangle (smaller)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -10);
                    this.ctx.lineTo(-5, 5);
                    this.ctx.lineTo(5, 5);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                    
                    // Spark effects trail
                    if (Math.random() < 0.5) {
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.globalAlpha = 0.7;
                        const sparkX = m.x - m.vx * 0.5 + (Math.random() - 0.5) * 5;
                        const sparkY = m.y - m.vy * 0.5 + (Math.random() - 0.5) * 5;
                        this.ctx.fillRect(sparkX, sparkY, 2, 2);
                        this.ctx.globalAlpha = 1;
                    }
                });

                // Render explosions
                this.explosions.forEach(exp => {
                    const progress = exp.time / exp.duration;
                    const currentRadius = exp.radius + (exp.maxRadius - exp.radius) * progress;
                    const alpha = 1 - progress;
                    
                    this.ctx.strokeStyle = `rgba(255, 102, 0, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#ff6600';
                    this.ctx.beginPath();
                    this.ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                });

                // Render lightning
                this.lightningBolts.forEach(bolt => {
                    const alpha = 1 - (bolt.time / bolt.duration);
                    this.ctx.strokeStyle = bolt.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = bolt.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.x1, bolt.y1);
                    this.ctx.lineTo(bolt.x2, bolt.y2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    this.ctx.globalAlpha = 1;
                });
            },

            renderParallaxStars() {
                this.starLayers.forEach(layer => {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${layer.opacity})`;
                    layer.stars.forEach(star => {
                        star.y += layer.speed;
                        if (star.y > 1280) {
                            star.y = 0;
                            star.x = Math.random() * 720;
                        }
                        this.ctx.fillRect(star.x, star.y, layer.size, layer.size);
                    });
                });
            },

            gameOver() {
                this.state.running = false;
                document.getElementById('touchLayer').classList.remove('active');
                document.getElementById('pauseBtn').classList.remove('active');
                document.getElementById('finalScore').textContent = this.state.score;
                document.getElementById('gameOverScreen').classList.add('active');
            },

            restart() {
                document.getElementById('gameOverScreen').classList.remove('active');
                this.startGame();
            },

            backToMenu() {
                document.getElementById('gameOverScreen').classList.remove('active');
                this.showMainMenu();
            }
        };

        game.init();
    </script>
</body>
</html>