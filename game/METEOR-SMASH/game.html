<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meteor Smash</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 720px;
            height: 100vh;
            max-height: 1280px;
            background: #000;
            overflow: hidden;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        @media (min-width: 721px) {
            #gameContainer {
                width: 720px;
                height: 1280px;
            }
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Ensure laser fortress visuals at screen edges are fully visible */
        canvas {
            image-rendering: auto;
        }

        #touchLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: none;
        }

        #touchLayer.active {
            display: block;
        }

        .hud-element {
            position: absolute;
            z-index: 5;
            pointer-events: none;
        }

        #hearts {
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .heart {
            width: 40px;
            height: 40px;
            background: #ff0066;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            filter: drop-shadow(0 0 10px #ff0066);
            animation: heartbeat 1.5s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #levelHud {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .level-text {
            color: #00ffff;
            font-size: 20px;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 5px;
        }

        .xp-bar {
            width: 250px;
            height: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #7fff00);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 15px #00ff00;
        }

        #bossHealthBar {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            border: 3px solid #ff0000;
            border-radius: 15px;
            padding: 10px 20px;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.5);
            z-index: 10;
        }

        #bossHealthBar.active {
            display: flex;
        }

        .boss-icon {
            font-size: 32px;
            filter: drop-shadow(0 0 10px #ff0000);
        }

        .boss-hp-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .boss-hp-bar-wrapper {
            width: 300px;
            height: 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .boss-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.2s;
            box-shadow: 0 0 15px #ff0000;
        }

        .boss-hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 8px #000, 0 0 4px #000, 1px 1px 2px #000, -1px -1px 2px #000;
            pointer-events: none;
            z-index: 1;
        }

        #currency {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .currency-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 20px;
            padding: 8px 15px;
            color: #fff;
            font-size: 16px;
            filter: drop-shadow(0 0 8px #00ff00);
        }

        .game-button {
            position: absolute;
            padding: 15px 30px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            filter: drop-shadow(0 0 20px #00ff00);
            transition: all 0.2s;
            z-index: 20;
            pointer-events: auto;
        }

        .game-button:hover, .game-button:active {
            transform: scale(1.1);
            filter: drop-shadow(0 0 30px #00ff00);
        }

        #pauseBtn {
            top: 130px;
            right: 20px;
            width: 60px;
            height: 60px;
            padding: 0;
            border-radius: 50%;
            font-size: 28px;
            display: none;
        }

        #pauseBtn.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 100;
        }

        #pauseMenu.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .pause-title {
            font-size: 64px;
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            margin-bottom: 60px;
            animation: pulse 2s infinite;
        }

        .pause-menu-button {
            padding: 20px 60px;
            margin: 15px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            filter: drop-shadow(0 0 20px #00ff00);
            transition: all 0.2s;
        }

        .pause-menu-button:hover, .pause-menu-button:active {
            transform: scale(1.1);
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0035 0%, #1a0050 25%, #2a0070 50%, #1a0050 75%, #0a0035 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow: hidden;
        }

        #loadingScreen::before {
            content: '';
            position: absolute;
            width: 300%;
            height: 300%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(0, 255, 0, 0.1) 0%, transparent 60%);
            animation: rotate 25s linear infinite;
        }
        
        #loadingScreen::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 50%, white, transparent),
                radial-gradient(1px 1px at 70% 40%, white, transparent);
            background-size: 200% 200%, 250% 250%, 300% 300%, 400% 400%, 350% 350%, 450% 450%, 500% 500%;
            background-position: 0% 0%;
            animation: starfield 120s linear infinite;
            opacity: 0.6;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes starfield {
            from { background-position: 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%; }
            to { background-position: 100% 100%, 150% 150%, 200% 200%, 250% 250%, 200% 200%, 300% 300%, 350% 350%; }
        }

        #loadingScreen.hidden {
            animation: fadeOut 0.5s ease-out forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        .loading-title {
            font-size: 72px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff00, #00ffff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: float 3s ease-in-out infinite, gradientShift 4s ease-in-out infinite, neonPulse 2s ease-in-out infinite;
            text-align: center;
            margin-bottom: 60px;
            filter: drop-shadow(0 0 30px rgba(0, 255, 255, 0.8)) drop-shadow(0 0 60px rgba(255, 0, 255, 0.6));
            position: relative;
            z-index: 1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes neonPulse {
            0%, 100% { filter: drop-shadow(0 0 30px rgba(0, 255, 255, 0.8)) drop-shadow(0 0 60px rgba(255, 0, 255, 0.6)); }
            50% { filter: drop-shadow(0 0 50px rgba(0, 255, 255, 1)) drop-shadow(0 0 80px rgba(255, 0, 255, 0.8)); }
        }

        .loading-bar {
            width: 400px;
            max-width: 80%;
            height: 28px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid rgba(0, 255, 255, 0.5);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.4), 
                inset 0 0 15px rgba(0, 0, 0, 0.8),
                0 0 60px rgba(255, 0, 255, 0.3);
            position: relative;
            z-index: 1;
        }

        .loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            to { left: 100%; }
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #00ff00, #00ffff);
            background-size: 300% 100%;
            width: 0%;
            animation: loadProgress 3s ease-in-out forwards, waveEffect 1.5s ease-in-out infinite;
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.9),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            position: relative;
        }

        @keyframes loadProgress {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        @keyframes waveEffect {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .loading-text {
            margin-top: 20px;
            color: #00ffff;
            font-size: 18px;
            opacity: 0.8;
            z-index: 1;
            position: relative;
        }

        .loading-text::after {
            content: '';
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0035 0%, #1a0050 50%, #0a0035 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            overflow: hidden;
        }
        
        #mainMenu::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 10% 20%, white, transparent),
                radial-gradient(2px 2px at 90% 80%, white, transparent),
                radial-gradient(1px 1px at 50% 10%, white, transparent),
                radial-gradient(1px 1px at 80% 30%, white, transparent),
                radial-gradient(2px 2px at 30% 70%, white, transparent),
                radial-gradient(1px 1px at 60% 90%, white, transparent),
                radial-gradient(1px 1px at 20% 50%, white, transparent),
                radial-gradient(1px 1px at 70% 60%, white, transparent);
            background-size: 200% 200%;
            animation: floatingStars 60s linear infinite;
            opacity: 0.7;
        }
        
        #mainMenu::after {
            content: 'üåë';
            position: absolute;
            font-size: 80px;
            opacity: 0.15;
            animation: driftingAsteroid 40s linear infinite;
        }
        
        @keyframes floatingStars {
            from { background-position: 0% 0%; }
            to { background-position: 100% 100%; }
        }
        
        @keyframes driftingAsteroid {
            0% { 
                left: -100px; 
                top: 20%; 
                transform: rotate(0deg);
            }
            50% {
                left: 50%;
                top: 50%;
                transform: rotate(180deg);
            }
            100% { 
                left: calc(100% + 100px); 
                top: 80%; 
                transform: rotate(360deg);
            }
        }

        #mainMenu.active {
            display: flex;
        }

        .menu-title {
            font-size: min(80px, 15vw);
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff00, #00ffff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: float 3s ease-in-out infinite, gradientShift 4s ease-in-out infinite;
            text-align: center;
            line-height: 1.2;
            margin-bottom: 80px;
            filter: drop-shadow(0 0 40px rgba(0, 255, 255, 0.8)) drop-shadow(0 0 80px rgba(255, 0, 255, 0.6));
        }

        .menu-button {
            width: 280px;
            height: 80px;
            padding: 0;
            margin: 15px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.4));
            border: 4px solid #00ffff;
            border-radius: 15px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.6), 
                inset 0 0 20px rgba(0, 255, 255, 0.2),
                0 0 60px rgba(0, 255, 255, 0.4);
            transition: all 0.3s;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .menu-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            animation: buttonShine 3s linear infinite;
        }
        
        @keyframes buttonShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .menu-button:hover, .menu-button:active {
            transform: scale(1.05);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.6));
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 1), 
                inset 0 0 30px rgba(0, 255, 255, 0.4),
                0 0 80px rgba(0, 255, 255, 0.6);
        }

        .menu-button.secondary {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(255, 0, 255, 0.4));
            border-color: #ff00ff;
            box-shadow: 
                0 0 30px rgba(255, 0, 255, 0.6), 
                inset 0 0 20px rgba(255, 0, 255, 0.2),
                0 0 60px rgba(255, 0, 255, 0.4);
        }

        .menu-button.secondary:hover, .menu-button.secondary:active {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.4), rgba(255, 0, 255, 0.6));
            box-shadow: 
                0 0 50px rgba(255, 0, 255, 1), 
                inset 0 0 30px rgba(255, 0, 255, 0.4),
                0 0 80px rgba(255, 0, 255, 0.6);
        }

        #skillScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 40px 20px;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
        }

        #skillScreen.active {
            display: flex;
        }

        .skill-title {
            font-size: clamp(24px, 6vw, 48px);
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            margin-bottom: 30px;
            text-align: center;
        }

        #skillsContainer {
            display: flex;
            gap: clamp(15px, 2vw, 30px); /* Responsive gap - smaller on mobile */
            justify-content: center;
            flex-wrap: nowrap; /* Keep 3 cards in single row */
            margin-bottom: 30px;
            padding: 60px 15px 40px 15px; /* Reduced horizontal padding */
            align-items: center;
            max-width: 100%;
            overflow: visible; /* Allow icon to extend outside */
        }

        /* Further reduce gap on very small screens */
        @media (max-width: 400px) {
            #skillsContainer {
                gap: 12px;
                padding: 60px 10px 40px 10px;
            }
        }

        /* THREE-LAYER SKILL CARD SYSTEM */
        
        /* Layer 1 - Outer Frame (div1) - Static neon border, never animates */
        .skill-card-outer {
            position: relative;
            width: min(180px, 25vw); /* Reduced from 220px and 28vw */
            aspect-ratio: 2/3;
            background: transparent;
            border: 3px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            overflow: visible; /* CRITICAL: Allow icon to extend outside */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transition: box-shadow 0.3s ease;
            flex-shrink: 1; /* Allow slight shrinking if needed */
            max-width: 30%; /* Ensure no card exceeds 30% of container width */
            will-change: box-shadow; /* Optimize for animations */
        }

        .skill-card-outer:hover {
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            .skill-card-outer {
                width: min(160px, 27vw); /* Further reduce on mobile */
                max-width: 29%;
            }
        }

        @media (max-width: 400px) {
            .skill-card-outer {
                width: min(140px, 28vw); /* Even smaller on very small screens */
                max-width: 30%;
            }
        }

        /* Modern Premium Selection Effect - Soft pulsing glow in the gap */
        .skill-card-outer.selected {
            border-color: #ff00ff;
            box-shadow: 0 0 35px rgba(255, 0, 255, 0.8);
        }

        /* Soft pulsing glow layer - stays in gap between Layer 1 and Layer 2 */
        .skill-card-outer.selected::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            right: 3px;
            bottom: 3px;
            background: radial-gradient(
                ellipse at center,
                rgba(255, 0, 255, 0.15) 0%,
                rgba(255, 0, 255, 0.08) 50%,
                transparent 100%
            );
            border-radius: 6px;
            z-index: 0;
            animation: softPulse 2s ease-in-out infinite;
            pointer-events: none;
        }

        /* Elegant animated border line tracing the edge */
        .skill-card-outer.selected::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            padding: 3px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 0, 255, 0.8) 30%,
                rgba(0, 255, 255, 0.8) 70%,
                transparent 100%
            );
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            z-index: 0;
            animation: tracingLine 3s linear infinite;
            pointer-events: none;
        }

        @keyframes softPulse {
            0%, 100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        @keyframes tracingLine {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 200% 0%;
            }
        }

        /* Reduce glow intensity on small screens to prevent overflow issues */
        @media (max-width: 600px) {
            .skill-card-outer {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            }
            
            .skill-card-outer:hover {
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            }
            
            .skill-card-outer.selected {
                box-shadow: 0 0 25px rgba(255, 0, 255, 0.8);
            }
        }

        /* Layer 2 - Inner Frame (div2) - Contains text, handles animations */
        .skill-card-inner {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            background: rgba(10, 10, 40, 0.95);
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 10px;
            padding: clamp(40px, 8vw, 50px) clamp(10px, 2vw, 15px) clamp(40px, 8vw, 50px) clamp(10px, 2vw, 15px); /* Top: icon clearance | Bottom: tier bar clearance */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Centers name + description between icon area and tier bar */
            text-align: center;
            transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
            box-shadow: 
                0 0 15px rgba(0, 255, 255, 0.3),
                inset 0 0 15px rgba(0, 255, 255, 0.08);
            z-index: 1;
            overflow: hidden; /* Clips tier bar to the card's rounded bottom corners (icon is a sibling, not affected) */
            will-change: transform; /* Optimize for animations */
        }

        /* Hover State - Layer 2 scales up slightly with soft glow */
        .skill-card-outer:hover .skill-card-inner {
            transform: scale(1.02);
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.5),
                inset 0 0 20px rgba(0, 255, 255, 0.12);
        }

        /* Click/Press State - Quick shrink then return */
        .skill-card-outer:active .skill-card-inner {
            animation: pressAnimation 0.3s ease;
        }

        @keyframes pressAnimation {
            0% { transform: scale(1); }
            40% { transform: scale(0.97); }
            100% { transform: scale(1.02); }
        }

        /* Selected state - Change Layer 2 border and background with smooth transition */
        .skill-card-outer.selected .skill-card-inner {
            border-color: rgba(255, 0, 255, 0.8);
            background: rgba(20, 5, 30, 0.95);
            box-shadow: 
                0 0 30px rgba(255, 0, 255, 0.5),
                inset 0 0 20px rgba(255, 0, 255, 0.12);
        }

        /* Layer 3 - Icon Layer (div3) - Dedicated wrapper, overlaps Layer 1 */
        .skill-icon-wrapper {
            position: absolute;
            top: clamp(-30px, -5vw, -35px); /* Responsive top position */
            left: 50%;
            transform: translateX(-50%);
            width: clamp(55px, 10vw, 70px); /* Responsive icon size */
            height: clamp(55px, 10vw, 70px);
            z-index: 10; /* Above all other layers */
            pointer-events: none; /* Don't interfere with card clicks */
        }

        .skill-icon {
            position: relative; /* Anchor for absolutely-positioned image overlay */
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.5));
            border: 3px solid #00ffff;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(28px, 5vw, 38px); /* Responsive font size */
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.6),
                inset 0 0 15px rgba(0, 255, 255, 0.2);
            transition: box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
            will-change: box-shadow; /* Optimize for animations */
        }

        /* Hover state - Soft glow increase on icon */
        .skill-card-outer:hover .skill-icon {
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.8),
                inset 0 0 18px rgba(0, 255, 255, 0.3);
        }

        /* Selected state - Change icon colors with smooth transition */
        .skill-card-outer.selected .skill-icon {
            border-color: #ff00ff;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(255, 0, 255, 0.5));
            box-shadow: 
                0 0 30px rgba(255, 0, 255, 0.8),
                inset 0 0 18px rgba(255, 0, 255, 0.3);
        }

        /* Reduce icon glow on mobile to prevent overflow */
        @media (max-width: 600px) {
            .skill-icon {
                box-shadow: 
                    0 0 15px rgba(0, 255, 255, 0.6),
                    inset 0 0 10px rgba(0, 255, 255, 0.2);
            }
            
            .skill-card-outer:hover .skill-icon {
                box-shadow: 
                    0 0 20px rgba(0, 255, 255, 0.8),
                    inset 0 0 12px rgba(0, 255, 255, 0.3);
            }
            
            .skill-card-outer.selected .skill-icon {
                box-shadow: 
                    0 0 20px rgba(255, 0, 255, 0.8),
                    inset 0 0 12px rgba(255, 0, 255, 0.3);
            }
        }

        /* Icon image support ‚Äî absolutely overlays the fallback emoji inside .skill-icon */
        .skill-icon img.skill-icon-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;       /* Preserves aspect ratio ‚Äî no stretching or distortion */
            background: transparent;   /* PNG transparency shows the neon container behind */
            border-radius: 12px;
            display: block;
        }

        /* Skill Name */
        .skill-name {
            font-size: clamp(14px, 2.5vw, 17px); /* Responsive font size */
            color: #00ffff;
            font-weight: bold;
            margin-bottom: clamp(8px, 1.5vw, 12px);
            text-shadow: 0 0 12px rgba(0, 255, 255, 0.8);
            letter-spacing: 0.5px;
            line-height: 1.3;
        }

        .skill-card-outer.selected .skill-name {
            color: #ff00ff;
            text-shadow: 0 0 12px rgba(255, 0, 255, 0.8);
        }

        /* Skill Description */
        .skill-description {
            font-size: clamp(10px, 1.8vw, 12px); /* Responsive font size */
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
            letter-spacing: 0.3px;
        }

        /* Tier indicator bar ‚Äî trapezoidal banner anchored to the bottom of the inner card.
           clip-path creates the sketch shape: narrower at the top, widening to full width at the base. */
        .skill-tier-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: clamp(36px, 7vw, 46px);
            clip-path: polygon(7% 0%, 93% 0%, 100% 100%, 0% 100%);
            background: linear-gradient(180deg, rgba(0, 255, 255, 0.15) 0%, rgba(0, 255, 255, 0.45) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ffff;
            font-size: clamp(11px, 2.5vw, 14px);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            transition: background 0.25s ease, color 0.25s ease, text-shadow 0.25s ease;
        }

        /* Tier bar ‚Äî selected state shifts to magenta */
        .skill-card-outer.selected .skill-tier-bar {
            background: linear-gradient(180deg, rgba(255, 0, 255, 0.15) 0%, rgba(255, 0, 255, 0.45) 100%);
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
        }

        /* Upgrade Button - Default (Disabled) State */
        #confirmSkill {
            min-width: 240px;
            padding: 15px 40px;
            background: rgba(25, 25, 40, 0.9);
            border: 2px solid #444;
            border-radius: 8px;
            color: #555;
            font-size: 20px;
            font-weight: bold;
            cursor: not-allowed;
            filter: none;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            transition: all 0.25s ease;
            letter-spacing: 2px;
            will-change: transform, box-shadow;
        }

        /* Upgrade Button - Active State (when skill selected) */
        #confirmSkill:not(:disabled) {
            background: rgba(0, 15, 0, 0.85);
            border-color: #00ff00;
            color: #00ff00;
            cursor: pointer;
            filter: none;
            box-shadow:
                0 0 14px rgba(0, 255, 0, 0.4),
                inset 0 0 20px rgba(0, 255, 0, 0.08);
        }

        #confirmSkill:not(:disabled):hover {
            transform: scale(1);
            filter: none;
            box-shadow:
                0 0 24px rgba(0, 255, 0, 0.6),
                inset 0 0 24px rgba(0, 255, 0, 0.13);
        }

        #confirmSkill:not(:disabled):active {
            transform: scale(0.96);
            box-shadow:
                0 0 8px rgba(0, 255, 0, 0.3),
                inset 0 0 12px rgba(0, 255, 0, 0.06);
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #gameOverScreen.active {
            display: flex;
        }

        .game-over-title {
            font-size: clamp(48px, 10vw, 72px);
            color: #ff0066;
            text-shadow: 0 0 40px #ff0066;
            margin-bottom: 40px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .final-score {
            font-size: clamp(24px, 5vw, 36px);
            color: #00ffff;
            margin-bottom: 60px;
        }

        .game-over-button {
            padding: 20px 50px;
            margin: 15px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .game-over-button:hover, .game-over-button:active {
            transform: scale(1.1);
        }

        #helpScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 150;
            overflow-y: auto;
        }

        #helpScreen.active {
            display: block;
        }

        .help-container {
            max-width: 600px;
            margin: 40px auto;
            padding: 30px 20px;
        }

        .help-header {
            font-size: clamp(32px, 8vw, 48px);
            color: #00ff00;
            text-align: center;
            margin-bottom: 40px;
        }

        .help-section {
            background: rgba(26, 26, 62, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .help-section-title {
            font-size: clamp(20px, 5vw, 28px);
            color: #00ffff;
            margin-bottom: 20px;
        }

        .help-text {
            font-size: 16px;
            color: #ccc;
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .close-help-btn {
            display: block;
            margin: 30px auto;
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #00ff00;
            border-radius: 50px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }

        #bossWarning {
            position: absolute;
            top: 50%;
            left: 50px;
            transform: translateY(-50%);
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 50px #ff0000;
            z-index: 90;
            display: none;
            animation: bossWarningPulse 1s infinite;
            pointer-events: none;
            text-align: left;
        }

        @keyframes bossWarningPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.5; transform: translateY(-50%) scale(1.1); }
        }

        #bossWarning.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="720" height="1280"></canvas>
        <canvas id="touchLayer"></canvas>
        
        <div id="hearts" class="hud-element"></div>
        
        <div id="levelHud" class="hud-element">
            <div class="level-text">Level <span id="levelNum">1</span></div>
            <div class="xp-bar">
                <div class="xp-fill" id="xpFill"></div>
            </div>
        </div>
        
        <!-- Boss Health Bar (fixed position, appears when boss is active) -->
        <div id="bossHealthBar">
            <div class="boss-icon">üíÄ</div>
            <div class="boss-hp-container">
                <div class="boss-hp-bar-wrapper">
                    <div class="boss-hp-fill" id="bossHpFill"></div>
                    <div class="boss-hp-text" id="bossHpText">1000 / 1000</div>
                </div>
            </div>
        </div>
        
        <div id="currency" class="hud-element">
            <div class="currency-display">‚≠ê <span id="scoreDisplay">0</span></div>
            <div class="currency-display">üí∞ <span id="coinDisplay">0</span></div>
        </div>
        
        <div id="bossWarning">‚ö†Ô∏è BOSS APPROACHING ‚ö†Ô∏è</div>
        
        <div id="bossTimer" class="hud-element" style="top: 80px; left: 20px; display: none;">
            <div style="background: rgba(0,0,0,0.8); border: 2px solid #ff0000; border-radius: 10px; padding: 10px 15px;">
                <div style="color: #ff0000; font-size: 14px; margin-bottom: 5px;">üëπ NEXT BOSS</div>
                <div id="bossTimerText" style="color: #fff; font-size: 20px; font-weight: bold; text-align: center;">3:00</div>
            </div>
        </div>
        
        <button id="pauseBtn" class="game-button" onclick="game.togglePause()">‚è∏</button>
        
        <div id="loadingScreen">
            <div class="loading-title">METEOR SMASH</div>
            <div class="loading-bar">
                <div class="loading-fill"></div>
            </div>
            <div class="loading-text">Loading</div>
        </div>
        
        <div id="mainMenu">
            <div class="menu-title">METEOR<br>SMASH</div>
            <button class="menu-button" onclick="game.startGame()">‚ñ∂ PLAY</button>
            <button class="menu-button secondary" onclick="game.showHelp()">‚ùì HOW TO PLAY</button>
        </div>
        
        <div id="pauseMenu">
            <div class="pause-title">‚è∏ PAUSED</div>
            <button class="pause-menu-button" onclick="game.resumeGame()">‚ñ∂ RESUME</button>
            <button class="pause-menu-button" onclick="game.returnToMainMenu()">üè† MAIN MENU</button>
        </div>
        
        <div id="skillScreen">
            <div class="skill-title">‚¨ÜÔ∏è LEVEL UP! Choose an Upgrade:</div>
            <div id="skillsContainer"></div>
            <button id="confirmSkill" onclick="game.confirmSkill()" disabled>‚úÖ CONFIRM</button>
        </div>
        
        <div id="gameOverScreen">
            <div class="game-over-title">üíÄ GAME OVER</div>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <button class="game-over-button" onclick="game.restart()">üîÑ PLAY AGAIN</button>
            <button class="game-over-button" onclick="game.backToMenu()">üè† MAIN MENU</button>
        </div>
        
        <div id="helpScreen">
            <div class="help-container">
                <div class="help-header">üìñ HOW TO PLAY</div>
                
                <div class="help-section">
                    <div class="help-section-title">üéÆ Controls</div>
                    <p class="help-text">Desktop: Use WASD or Arrow Keys to move</p>
                    <p class="help-text">Mobile: Touch and drag to move</p>
                    <p class="help-text">Your ship fires automatically!</p>
                </div>

                <div class="help-section">
                    <div class="help-section-title">üëæ Bosses</div>
                    <p class="help-text">Powerful bosses appear every 3 minutes!</p>
                    <p class="help-text">Each boss has unique attack patterns</p>
                    <p class="help-text">Defeat them for massive rewards!</p>
                </div>

                <div class="help-section">
                    <div class="help-section-title">üéØ Skills</div>
                    <p class="help-text">üî´ Support Fighters ‚Äì Deploy escort ships that fire alongside you</p>
                    <p class="help-text">üí• Explosive Rounds ‚Äì Shots explode on impact, dealing area damage</p>
                    <p class="help-text">‚ö° Chain Lightning ‚Äì Releases lightning that jumps between enemies</p>
                    <p class="help-text">üöÄ Homing Missiles ‚Äì Launch missiles that track and hunt targets</p>
                    <p class="help-text">üîÑ Ricochet Bullets ‚Äì Bullets bounce to new targets after hitting</p>
                    <p class="help-text">üéØ Piercing Bullets ‚Äì Bullets pass through multiple enemies</p>
                    <p class="help-text">üî¥ Laser Fortress ‚Äì Summons laser turrets for sustained fire support</p>
                </div>
            </div>
            <button class="close-help-btn" onclick="game.closeHelp()">‚úÖ GOT IT!</button>
        </div>

    <script>
        const SKILLS = {
            support_fighters: {
                id: 'support_fighters',
                name: 'Extra Firepower',
                icon: './img/support_fighters.png',
                description: 'Deploy escort ships that fire alongside you',
                maxTier: 2,
                conflicts: []
            },
            explosive_bullets: {
                id: 'explosive_bullets',
                name: 'Explosive Rounds',
                icon: './img/explosive_bullets.png',
                description: 'Shots explode on impact, dealing area damage',
                maxTier: 2,
                conflicts: []
            },
            chain_lightning: {
                id: 'chain_lightning',
                name: 'Chain Lightning',
                icon: './img/chain_lightning.png',
                description: 'Releases lightning that jumps between enemiess',
                maxTier: 2,
                conflicts: []
            },
            homing_missiles: {
                id: 'homing_missiles',
                name: 'Homing Missiles',
                icon: './img/homing_missiles.png',
                description: 'Launch missiles that track and hunt targets',
                maxTier: 2,
                conflicts: []
            },
            ricochet_bullets: {
                id: 'ricochet_bullets',
                name: 'Ricochet Bullets',
                icon: './img/ricochet_bullets.png',
                description: 'Bullets bounce to new targets after hitting',
                maxTier: 2,
                conflicts: ['piercing_bullets']
            },
            piercing_bullets: {
                id: 'piercing_bullets',
                name: 'Piercing Bullets',
                icon: './img/piercing_bullets.png',
                description: 'Bullets pass through multiple enemies',
                maxTier: 2,
                conflicts: ['ricochet_bullets']
            },
            laser_fortress: {
                id: 'laser_fortress',
                name: 'Laser Fortress',
                icon: './img/laser_fortress.png',
                description: 'Summons laser turrets for sustained fire support',
                maxTier: 2,
                conflicts: []
            }
        };

        // Fallback emojis rendered instantly when an external image is unavailable or fails to load.
        // Each emoji matches the icon already shown in the help screen for visual consistency.
        const DEFAULT_ICON_EMOJIS = {
            support_fighters:  'üî´',
            explosive_bullets: 'üí•',
            chain_lightning:   '‚ö°',
            homing_missiles:   'üöÄ',
            ricochet_bullets:  'üîÑ',
            piercing_bullets:  'üéØ',
            laser_fortress:    'üî¥'
        };

        // BOSS DEFINITIONS
        const BOSSES = {
            // Boss 1: Flame Demon - Fire-based attacks
            flame_demon: {
                id: 'flame_demon',
                name: 'Flame Demon',
                hp: 1000,
                size: 150,
                color: '#ff3300',
                skills: [
                    {
                        name: 'Fire Circle',
                        cooldown: 3000,
                        execute: function(boss, game) {
                            // Spawns 8 fire projectiles in a circle
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                game.bossProjectiles.push({
                                    x: boss.x,
                                    y: boss.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    size: 15,
                                    color: '#ff6600',
                                    damage: 1
                                });
                            }
                        }
                    },
                    {
                        name: 'Flame Breath',
                        cooldown: 5000,
                        execute: function(boss, game) {
                            // Shoots a stream of fire towards player
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const dx = game.player.x - boss.x;
                                    const dy = game.player.y - boss.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const spread = (Math.random() - 0.5) * 0.5;
                                    
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: (dx / dist) * 6 + spread,
                                        vy: (dy / dist) * 6 + spread,
                                        size: 12,
                                        color: '#ff9900',
                                        damage: 1
                                    });
                                }, i * 50);
                            }
                        }
                    },
                    {
                        name: 'Meteor Shower',
                        cooldown: 8000,
                        execute: function(boss, game) {
                            // Rains fire from above
                            for (let i = 0; i < 15; i++) {
                                setTimeout(() => {
                                    game.bossProjectiles.push({
                                        x: Math.random() * 720,
                                        y: -50,
                                        vx: 0,
                                        vy: 8,
                                        size: 20,
                                        color: '#ff0000',
                                        damage: 1
                                    });
                                }, i * 200);
                            }
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Sinusoidal horizontal movement
                    boss.x = 360 + Math.sin(time / 1000) * 250;
                    boss.y = 200 + Math.sin(time / 2000) * 50;
                }
            },
            
            // Boss 2: Void Kraken - Dark energy attacks
            void_kraken: {
                id: 'void_kraken',
                name: 'Void Kraken',
                hp: 1200,
                size: 160,
                color: '#9900ff',
                skills: [
                    {
                        name: 'Tentacle Slam',
                        cooldown: 4000,
                        execute: function(boss, game) {
                            // Creates shockwave lines
                            const targetX = game.player.x;
                            const targetY = game.player.y;
                            
                            for (let i = -2; i <= 2; i++) {
                                setTimeout(() => {
                                    game.bossProjectiles.push({
                                        x: boss.x + i * 80,
                                        y: boss.y,
                                        vx: 0,
                                        vy: 10,
                                        size: 40,
                                        color: '#cc00ff',
                                        damage: 1
                                    });
                                }, Math.abs(i) * 100);
                            }
                        }
                    },
                    {
                        name: 'Void Spiral',
                        cooldown: 6000,
                        execute: function(boss, game) {
                            // Spiral pattern of dark energy
                            let angle = 0;
                            for (let i = 0; i < 30; i++) {
                                setTimeout(() => {
                                    angle += 0.3;
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: Math.cos(angle) * 5,
                                        vy: Math.sin(angle) * 5,
                                        size: 12,
                                        color: '#ff00ff',
                                        damage: 1
                                    });
                                }, i * 80);
                            }
                        }
                    },
                    {
                        name: 'Dark Sphere',
                        cooldown: 7000,
                        execute: function(boss, game) {
                            // Homing dark orb
                            game.bossProjectiles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: 0,
                                vy: 2,
                                size: 30,
                                color: '#6600cc',
                                damage: 2,
                                homing: true,
                                speed: 3
                            });
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Figure-8 movement
                    const t = time / 2000;
                    boss.x = 360 + Math.sin(t) * 200;
                    boss.y = 250 + Math.sin(t * 2) * 100;
                }
            },
            
            // Boss 3: Cyber Skull - Laser and tech attacks
            cyber_skull: {
                id: 'cyber_skull',
                name: 'Cyber Skull',
                hp: 1500,
                size: 140,
                color: '#00ffff',
                skills: [
                    {
                        name: 'Laser Sweep',
                        cooldown: 5000,
                        execute: function(boss, game) {
                            // Rotating laser beam
                            boss.laserSweep = {
                                active: true,
                                angle: 0,
                                duration: 3000,
                                startTime: Date.now()
                            };
                        }
                    },
                    {
                        name: 'EMP Pulse',
                        cooldown: 6000,
                        execute: function(boss, game) {
                            // Expanding ring that slows player
                            game.bossProjectiles.push({
                                x: boss.x,
                                y: boss.y,
                                radius: 0,
                                maxRadius: 300,
                                expandSpeed: 5,
                                size: 5,
                                color: '#00ffff',
                                damage: 1,
                                ring: true
                            });
                        }
                    },
                    {
                        name: 'Missile Barrage',
                        cooldown: 7000,
                        execute: function(boss, game) {
                            // Rapid fire missiles
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    const angle = (i / 12) * Math.PI * 2;
                                    game.bossProjectiles.push({
                                        x: boss.x,
                                        y: boss.y,
                                        vx: Math.cos(angle) * 6,
                                        vy: Math.sin(angle) * 6,
                                        size: 10,
                                        color: '#00ff00',
                                        damage: 1
                                    });
                                }, i * 100);
                            }
                        }
                    }
                ],
                movement: function(boss, game, time) {
                    // Circular orbit movement
                    const t = time / 3000;
                    boss.x = 360 + Math.cos(t) * 220;
                    boss.y = 300 + Math.sin(t) * 150;
                }
            }
        };

        // IMAGE OVERRIDE CONFIGURATION
        // Set image URLs here to use custom sprites, or leave as null to use default visuals
        const IMAGE_OVERRIDES = {
            playerShip: './img/spacecraft.png',       // Main player ship
            supportShip: './img/support-fighter.png',      // Support fighter ships
            laserFortressL1: './img/laser-fortress-lv1.png',  // Laser fortress level 1 turret
            laserFortressL2: './img/laser-fortress-lv2.png',  // Laser fortress level 2 turrets
            boss1: './img/boss-1.png',            // First boss type
            boss2: './img/boss-2.png',            // Second boss type
            boss3: './img/boss-3.png',            // Third boss type
            heart: './img/heart.png'             // Heart/life icon
        };

        // IMAGE SCALE CONFIGURATION (affects visual size only, NOT hitboxes)
        // Set to percentage (e.g., 150 for 150%) or null to use default size
        const IMAGE_SCALES = {
            playerShip: 110,       // Main player ship scale
            supportShip: 110,      // Support fighter ships scale
            laserFortress: 140     // Laser fortress turret scale
        };

        const game = {
            canvas: null,
            ctx: null,
            starLayers: [],
            loadedImages: {},  // Store loaded images

            state: {
                running: false,
                paused: false,
                score: 0,
                coins: 0,
                selectedSkill: null,
                gameTime: 0,
                lastBossSpawn: 0
            },

            player: {
                x: 360,
                y: 1100,
                width: 40,
                height: 60,
                speed: 8,
                hearts: 3,
                level: 1,
                xp: 0,
                xpToNext: 100,
                damage: 20,
                attackSpeed: 3,
                skills: {},
                lastShot: 0,
                invincible: false,
                invincibleUntil: 0,
                damageFlashUntil: 0
            },

            bullets: [],
            asteroids: [],
            boss: null,
            bossProjectiles: [],
            keys: {},
            supportFighters: [],
            explosions: [],
            lightningBolts: [],
            missiles: [],
            laserShips: [],
            lastLightning: 0,
            lastMissile: 0,
            lastLaserActivation: 0,

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Make canvas responsive
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.initStarLayers();
                this.setupEventListeners();
                this.preloadImages();
                this.simulateLoading();
            },

            preloadImages() {
                // Preload all image overrides
                Object.keys(IMAGE_OVERRIDES).forEach(key => {
                    if (IMAGE_OVERRIDES[key]) {
                        const img = new Image();
                        img.onload = () => {
                            this.loadedImages[key] = img;
                        };
                        img.onerror = () => {
                            console.warn(`Failed to load image for ${key}, using default`);
                            this.loadedImages[key] = null;
                        };
                        img.src = IMAGE_OVERRIDES[key];
                    }
                });
            },

            resizeCanvas() {
                // Always use 720√ó1280 internal resolution; CSS handles visual scaling
                this.canvas.width = 720;
                this.canvas.height = 1280;
                this.scaleX = 1;
                this.scaleY = 1;
            },

            initStarLayers() {
                this.starLayers = [
                    { stars: [], speed: 0.2, size: 1, count: 50, opacity: 0.4 },
                    { stars: [], speed: 0.5, size: 2, count: 80, opacity: 0.6 },
                    { stars: [], speed: 1.0, size: 3, count: 100, opacity: 0.9 }
                ];

                this.starLayers.forEach(layer => {
                    for (let i = 0; i < layer.count; i++) {
                        layer.stars.push({
                            x: Math.random() * 720,
                            y: Math.random() * 1280
                        });
                    }
                });
            },

            setupEventListeners() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // Touch controls
                const touchLayer = document.getElementById('touchLayer');
                touchLayer.width = 720;
                touchLayer.height = 1280;

                let touching = false;

                const getTouchPos = (e) => {
                    const rect = touchLayer.getBoundingClientRect();
                    const touch = e.touches[0];
                    return {
                        x: ((touch.clientX - rect.left) / rect.width) * 720,
                        y: ((touch.clientY - rect.top) / rect.height) * 1280
                    };
                };

                touchLayer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touching = true;
                    if (this.state.running && !this.state.paused) {
                        const pos = getTouchPos(e);
                        this.player.x = Math.max(30, Math.min(690, pos.x));
                        this.player.y = Math.max(30, Math.min(1250, pos.y));
                    }
                });

                touchLayer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (touching && this.state.running && !this.state.paused) {
                        const pos = getTouchPos(e);
                        this.player.x = Math.max(30, Math.min(690, pos.x));
                        this.player.y = Math.max(30, Math.min(1250, pos.y));
                    }
                });

                touchLayer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touching = false;
                });

                touchLayer.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    touching = false;
                });
            },

            simulateLoading() {
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    this.showMainMenu();
                }, 3000);
            },

            showMainMenu() {
                document.getElementById('mainMenu').classList.add('active');
            },

            startGame() {
                document.getElementById('mainMenu').classList.remove('active');
                this.clearBossUI();
                
                this.state = {
                    running: true,
                    paused: false,
                    score: 0,
                    coins: 0,
                    selectedSkill: null,
                    gameTime: 0,
                    lastBossSpawn: 0,
                    bossEncounterCount: 0 // Track number of boss encounters for skill frequency adjustment
                };

                this.player = {
                    x: 360,
                    y: 1100,
                    width: 40,
                    height: 60,
                    speed: 8,
                    hearts: 3,
                    level: 1,
                    xp: 0,
                    xpToNext: 100,
                    damage: 20,
                    attackSpeed: 3,
                    skills: {},
                    lastShot: 0
                };

                this.bullets = [];
                this.asteroids = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.supportFighters = [];
                this.explosions = [];
                this.lightningBolts = [];
                this.missiles = [];
                this.laserShips = [];
                this.lastLightning = 0;
                this.lastMissile = 0;
                this.lastLaserActivation = 0;

                this.updateHUD();
                document.getElementById('touchLayer').classList.add('active');
                document.getElementById('pauseBtn').classList.add('active');
                this.gameLoop();
            },

            togglePause() {
                this.state.paused = !this.state.paused;
                const pauseMenu = document.getElementById('pauseMenu');
                if (this.state.paused) {
                    pauseMenu.classList.add('active');
                } else {
                    pauseMenu.classList.remove('active');
                }
            },

            resumeGame() {
                this.state.paused = false;
                document.getElementById('pauseMenu').classList.remove('active');
            },

            returnToMainMenu() {
                this.state.paused = false;
                this.state.running = false;
                this.clearBossUI();
                document.getElementById('pauseMenu').classList.remove('active');
                document.getElementById('touchLayer').classList.remove('active');
                document.getElementById('pauseBtn').classList.remove('active');
                this.showMainMenu();
            },

            showHelp() {
                document.getElementById('helpScreen').classList.add('active');
            },

            closeHelp() {
                document.getElementById('helpScreen').classList.remove('active');
            },

            updateHUD() {
                const heartsContainer = document.getElementById('hearts');
                heartsContainer.innerHTML = '';
                const heartImg = this.loadedImages['heart'];
                
                for (let i = 0; i < this.player.hearts; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    
                    // Use custom heart image if available
                    if (heartImg) {
                        heart.style.background = 'none';
                        heart.style.clipPath = 'none';
                        heart.style.backgroundImage = `url(${heartImg.src})`;
                        heart.style.backgroundSize = 'cover';
                        heart.style.backgroundPosition = 'center';
                    }
                    
                    heartsContainer.appendChild(heart);
                }

                document.getElementById('levelNum').textContent = this.player.level;
                const xpPercent = (this.player.xp / this.player.xpToNext) * 100;
                document.getElementById('xpFill').style.width = xpPercent + '%';

                document.getElementById('scoreDisplay').textContent = this.state.score;
                document.getElementById('coinDisplay').textContent = this.state.coins;
            },

            gainXP(amount) {
                this.player.xp += amount;
                if (this.player.xp >= this.player.xpToNext) {
                    this.levelUp();
                }
                this.updateHUD();
            },

            levelUp() {
                this.player.level++;
                this.player.xp = 0;
                this.player.xpToNext = Math.floor(this.player.xpToNext * 1.5);
                this.state.paused = true;
                this.showSkillSelection();
            },

            showSkillSelection() {
                const container = document.getElementById('skillsContainer');
                container.innerHTML = '';

                const available = Object.values(SKILLS).filter(skill => {
                    const currentTier = this.player.skills[skill.id] || 0;
                    if (currentTier >= skill.maxTier) return false;
                    
                    for (let conflict of skill.conflicts) {
                        if (this.player.skills[conflict] > 0) return false;
                    }
                    return true;
                });

                const choices = [];
                const pool = [...available];
                while (choices.length < 3 && pool.length > 0) {
                    const idx = Math.floor(Math.random() * pool.length);
                    choices.push(pool[idx]);
                    pool.splice(idx, 1);
                }

                choices.forEach(skill => {
                    const currentTier = this.player.skills[skill.id] || 0;
                    const nextTier = currentTier + 1;

                    // Layer 1: Outer frame (div1)
                    const cardOuter = document.createElement('div');
                    cardOuter.className = 'skill-card-outer';
                    
                    // Layer 3: Icon wrapper (div3) - positioned at top, overlapping Layer 1
                    const iconWrapper = document.createElement('div');
                    iconWrapper.className = 'skill-icon-wrapper';
                    
                    const icon = document.createElement('div');
                    icon.className = 'skill-icon';

                    // 1. Render the fallback emoji immediately ‚Äî guarantees the icon is never
                    //    empty and prevents layout shifts regardless of image availability.
                    const fallbackEmoji = DEFAULT_ICON_EMOJIS[skill.id] || 'üéØ';
                    const fallback = document.createElement('span');
                    fallback.className = 'icon-fallback';
                    fallback.textContent = fallbackEmoji;
                    icon.appendChild(fallback);

                    // 2. Determine whether skill.icon is an image URL (relative path, absolute
                    //    path, full URL, or data URI).  Plain emoji strings are skipped.
                    const isImageUrl = skill.icon && (
                        skill.icon.startsWith('data:image/') ||
                        /\.(png|jpe?g|webp|gif|svg)(\?.*)?$/i.test(skill.icon)
                    );

                    // 3. If an image URL is present, attempt to load it asynchronously.
                    //    Handlers are attached before src is set to avoid a race when the
                    //    image is served from cache and loads synchronously.
                    if (isImageUrl) {
                        const img = document.createElement('img');
                        img.className = 'skill-icon-img';
                        img.alt = skill.name;

                        img.onload = function () {
                            // Image loaded successfully ‚Äî remove the fallback emoji so it
                            // does not bleed through transparent regions of the PNG.
                            const fb = icon.querySelector('.icon-fallback');
                            if (fb) fb.remove();
                        };

                        img.onerror = function () {
                            // Image failed (broken URL, CORS, unsupported format, etc.) ‚Äî
                            // remove the <img> entirely so no broken-image placeholder appears.
                            // The fallback emoji is already visible and stays in place.
                            img.remove();
                        };

                        img.src = skill.icon; // src set last ‚Äî triggers the load after handlers are ready
                        icon.appendChild(img);
                    }

                    iconWrapper.appendChild(icon);
                    
                    // Layer 2: Inner frame (div2) - contains text content
                    const cardInner = document.createElement('div');
                    cardInner.className = 'skill-card-inner';
                    cardInner.innerHTML = `
                        <div class="skill-name">${skill.name}</div>
                        <div class="skill-description">${skill.description}</div>
                        <div class="skill-tier-bar">Tier ${nextTier} / ${skill.maxTier}</div>
                    `;
                    
                    // Assemble the three layers
                    cardOuter.appendChild(iconWrapper);
                    cardOuter.appendChild(cardInner);
                    
                    cardOuter.onclick = () => this.selectSkill(skill, nextTier, cardOuter);
                    container.appendChild(cardOuter);
                });

                document.getElementById('skillScreen').classList.add('active');
            },

            selectSkill(skill, tier, cardElement) {
                document.querySelectorAll('.skill-card-outer').forEach(c => c.classList.remove('selected'));
                cardElement.classList.add('selected');
                this.state.selectedSkill = { id: skill.id, tier: tier };
                document.getElementById('confirmSkill').disabled = false;
            },

            confirmSkill() {
                if (!this.state.selectedSkill) return;

                const { id, tier } = this.state.selectedSkill;
                this.player.skills[id] = tier;

                if (id === 'support_fighters') {
                    this.initSupportFighters(tier);
                }
                if (id === 'laser_fortress') {
                    this.initLaserShips(tier);
                }

                document.getElementById('skillScreen').classList.remove('active');
                this.state.paused = false;
                this.updateHUD();
            },

            initSupportFighters(tier) {
                this.supportFighters = [];
                this.supportFighters.push({
                    offsetX: -60,
                    offsetY: -20,
                    lastShot: 0
                });
                this.supportFighters.push({
                    offsetX: 60,
                    offsetY: -20,
                    lastShot: 0
                });
            },

            initLaserShips(tier) {
                this.laserShips = [];
                if (tier === 1) {
                    // Level 1: 1 turret on left edge (half inside, half outside)
                    this.laserShips.push({
                        x: 20,
                        y: 400,
                        active: false,
                        activationTime: 0,
                        lastFired: 0,
                        lastDamageTick: 0
                    });
                } else {
                    // Level 2: 2 turrets on right edge (half inside, half outside)
                    this.laserShips.push({
                        x: 700,
                        y: 300,
                        active: false,
                        activationTime: 0,
                        lastFired: 0,
                        lastDamageTick: 0
                    });
                    this.laserShips.push({
                        x: 700,
                        y: 650,  // Moved down from 500 to 650 for better spacing
                        active: false,
                        activationTime: 0,
                        lastFired: 0,
                        lastDamageTick: 0
                    });
                }
            },

            clearBossUI() {
                // Hide boss warning
                const warning = document.getElementById('bossWarning');
                if (warning) {
                    warning.classList.remove('active');
                }
                
                // Hide boss timer (will show again when next boss countdown starts)
                const bossTimer = document.getElementById('bossTimer');
                if (bossTimer) {
                    bossTimer.style.display = 'none';
                }
                
                // Hide boss health bar
                const bossHealthBar = document.getElementById('bossHealthBar');
                if (bossHealthBar) {
                    bossHealthBar.classList.remove('active');
                }
            },

            spawnBoss() {
                const bossTypes = Object.values(BOSSES);
                const selectedBoss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                
                // Boss HP scales smoothly with time (every 60 seconds adds 15% HP)
                const timeMinutes = this.state.gameTime / 60;
                const hpScaling = 1 + (timeMinutes * 0.15);
                
                this.boss = {
                    ...selectedBoss,
                    x: 360,
                    y: 200,
                    currentHp: Math.floor(selectedBoss.hp * hpScaling),
                    maxHp: Math.floor(selectedBoss.hp * hpScaling),
                    skillCooldowns: selectedBoss.skills.map(() => 0),
                    laserSweep: null,
                    spawnTime: Date.now()
                };

                // Increment boss encounter counter
                this.state.bossEncounterCount++;

                // Show boss warning
                const warning = document.getElementById('bossWarning');
                warning.classList.add('active');
                setTimeout(() => {
                    warning.classList.remove('active');
                }, 3000);

                // Show and initialize boss health bar
                const bossHealthBar = document.getElementById('bossHealthBar');
                const bossHpFill = document.getElementById('bossHpFill');
                const bossHpText = document.getElementById('bossHpText');
                if (bossHealthBar) {
                    bossHealthBar.classList.add('active');
                    bossHpFill.style.width = '100%';
                    bossHpText.textContent = `${this.boss.currentHp} / ${this.boss.maxHp}`;
                }

                this.state.lastBossSpawn = this.state.gameTime;
            },

            updateBossHealthBar() {
                if (!this.boss) return;
                
                const bossHpFill = document.getElementById('bossHpFill');
                const bossHpText = document.getElementById('bossHpText');
                
                if (bossHpFill && bossHpText) {
                    const hpPercent = Math.max(0, (this.boss.currentHp / this.boss.maxHp) * 100);
                    bossHpFill.style.width = hpPercent + '%';
                    bossHpText.textContent = `${Math.max(0, Math.floor(this.boss.currentHp))} / ${this.boss.maxHp}`;
                }
            },

            gameLoop() {
                if (!this.state.running) return;
                
                if (!this.state.paused) {
                    this.update();
                    this.state.gameTime += 1/60;
                }
                
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            },

            takeDamage(amount) {
                const now = Date.now();
                
                // Check if player is invincible
                if (this.player.invincible || now < this.player.invincibleUntil) {
                    return; // No damage during invincibility
                }
                
                // Apply damage
                this.player.hearts -= amount;
                this.updateHUD();
                
                // Activate invincibility for 1.8 seconds (increased from 1 second)
                this.player.invincible = true;
                this.player.invincibleUntil = now + 1800;
                this.player.damageFlashUntil = now + 1800;
                
                // Deactivate invincibility after 1.8 seconds
                setTimeout(() => {
                    this.player.invincible = false;
                }, 1800);
                
                // Check game over
                if (this.player.hearts <= 0) {
                    this.gameOver();
                }
            },

            update() {
                // Keyboard movement
                if (this.keys['ArrowLeft'] || this.keys['a']) this.player.x -= this.player.speed;
                if (this.keys['ArrowRight'] || this.keys['d']) this.player.x += this.player.speed;
                if (this.keys['ArrowUp'] || this.keys['w']) this.player.y -= this.player.speed;
                if (this.keys['ArrowDown'] || this.keys['s']) this.player.y += this.player.speed;
                
                this.player.x = Math.max(30, Math.min(690, this.player.x));
                this.player.y = Math.max(30, Math.min(1250, this.player.y));

                // Boss spawning (first at 2 minutes, then every 3 minutes)
                const firstBossTime = 120; // 2 minutes
                const subsequentBossInterval = 180; // 3 minutes
                
                if (!this.boss) {
                    const timeSinceLastBoss = this.state.gameTime - this.state.lastBossSpawn;
                    const shouldSpawn = this.state.lastBossSpawn === 0 
                        ? this.state.gameTime >= firstBossTime 
                        : timeSinceLastBoss >= subsequentBossInterval;
                    
                    if (shouldSpawn) {
                        this.spawnBoss();
                    }
                }

                // Update boss countdown timer
                const bossTimerEl = document.getElementById('bossTimer');
                const bossTimerText = document.getElementById('bossTimerText');
                if (!this.boss) {
                    const isFirstBoss = this.state.lastBossSpawn === 0;
                    const targetTime = isFirstBoss ? firstBossTime : subsequentBossInterval;
                    const currentTime = isFirstBoss ? this.state.gameTime : (this.state.gameTime - this.state.lastBossSpawn);
                    const timeUntilBoss = targetTime - currentTime;
                    
                    if (timeUntilBoss > 0) {
                        bossTimerEl.style.display = 'block';
                        const minutes = Math.floor(timeUntilBoss / 60);
                        const seconds = Math.floor(timeUntilBoss % 60);
                        bossTimerText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        bossTimerEl.style.display = 'none';
                    }
                } else {
                    bossTimerEl.style.display = 'none';
                }

                // Shooting
                const now = Date.now();
                const tier = this.player.skills.support_fighters || 0;
                const mainShipFires = tier !== 1;

                if (mainShipFires && now - this.player.lastShot > 1000 / this.player.attackSpeed) {
                    this.shoot();
                    this.player.lastShot = now;
                }

                // Support fighters
                if (tier > 0) {
                    this.supportFighters.forEach(fighter => {
                        // Support fighters now fire at same rate as main ship
                        if (now - fighter.lastShot > 1000 / this.player.attackSpeed) {
                            const dmg = tier === 2 ? this.player.damage * 1.5 : this.player.damage;
                            this.bullets.push({
                                x: this.player.x + fighter.offsetX,
                                y: this.player.y + fighter.offsetY,
                                width: 6,
                                height: 16,
                                damage: dmg,
                                fromFighter: true
                            });
                            fighter.lastShot = now;
                        }
                    });
                }

                // Chain Lightning
                const lightningTier = this.player.skills.chain_lightning || 0;
                if (lightningTier > 0) {
                    const cooldown = lightningTier === 1 ? 3000 : 2000;
                    if (now - this.lastLightning > cooldown) {
                        this.activateChainLightning(lightningTier);
                        this.lastLightning = now;
                    }
                }

                // Homing Missiles
                const missileTier = this.player.skills.homing_missiles || 0;
                if (missileTier > 0) {
                    if (now - this.lastMissile > 3000) {
                        this.launchMissiles(missileTier);
                        this.lastMissile = now;
                    }
                }

                // Laser Fortress
                const laserTier = this.player.skills.laser_fortress || 0;
                if (laserTier > 0) {
                    const cooldown = 15000; // 15s cooldown for both levels, starts AFTER laser ends
                    const duration = laserTier === 1 ? 10000 : 15000; // L1: 10s fire, L2: 15s fire

                    // Deactivate expired turrets and record deactivation time
                    this.laserShips.forEach(ship => {
                        if (ship.active && now - ship.activationTime > duration) {
                            ship.active = false;
                            this.lastLaserActivation = now; // Cooldown starts after laser ends
                        }
                    });

                    // Activate all turrets if none active and cooldown has passed since last deactivation
                    const shouldActivate = !this.laserShips.some(ship => ship.active) &&
                                          (this.lastLaserActivation === 0 || now - this.lastLaserActivation > cooldown);

                    if (shouldActivate) {
                        this.laserShips.forEach(ship => {
                            ship.active = true;
                            ship.activationTime = now;
                            ship.lastDamageTick = 0;
                        });
                    }

                    // Apply damage while active
                    this.laserShips.forEach(ship => {
                        if (ship.active) {
                            this.applyLaserDamage(ship, laserTier);
                        }
                    });
                }

                // Update boss
                if (this.boss) {
                    const bossTime = now - this.boss.spawnTime;
                    this.boss.movement(this.boss, this, bossTime);

                    // Boss skills with frequency adjustment
                    // First boss encounter: reduce skill frequency (2x cooldown)
                    // Subsequent bosses: normal frequency
                    const cooldownMultiplier = this.state.bossEncounterCount === 1 ? 2.0 : 1.0;
                    
                    this.boss.skills.forEach((skill, idx) => {
                        const adjustedCooldown = skill.cooldown * cooldownMultiplier;
                        if (now - this.boss.skillCooldowns[idx] > adjustedCooldown) {
                            skill.execute(this.boss, this);
                            this.boss.skillCooldowns[idx] = now;
                        }
                    });

                    // Laser sweep for Cyber Skull
                    if (this.boss.laserSweep && this.boss.laserSweep.active) {
                        const elapsed = now - this.boss.laserSweep.startTime;
                        if (elapsed > this.boss.laserSweep.duration) {
                            this.boss.laserSweep.active = false;
                        } else {
                            this.boss.laserSweep.angle += 0.05;
                        }
                    }
                }

                // Update boss projectiles
                this.bossProjectiles.forEach((proj, idx) => {
                    if (proj.homing) {
                        const dx = this.player.x - proj.x;
                        const dy = this.player.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        proj.vx += (dx / dist) * 0.2;
                        proj.vy += (dy / dist) * 0.2;
                        const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
                        if (speed > proj.speed) {
                            proj.vx = (proj.vx / speed) * proj.speed;
                            proj.vy = (proj.vy / speed) * proj.speed;
                        }
                    }

                    if (proj.ring) {
                        proj.radius += proj.expandSpeed;
                        if (proj.radius > proj.maxRadius) {
                            this.bossProjectiles.splice(idx, 1);
                            return;
                        }
                    } else {
                        proj.x += proj.vx;
                        proj.y += proj.vy;
                    }

                    // Check collision with player (skip entirely while invincible)
                    const playerInvincible = this.player.invincible || now < this.player.invincibleUntil;
                    if (proj.ring) {
                        const dist = Math.sqrt((this.player.x - proj.x) ** 2 + (this.player.y - proj.y) ** 2);
                        if (Math.abs(dist - proj.radius) < 20 && !playerInvincible) {
                            this.takeDamage(proj.damage);
                        }
                    } else if (this.checkCollision(this.player, proj) && !playerInvincible) {
                        this.takeDamage(proj.damage);
                        this.bossProjectiles.splice(idx, 1);
                    }

                    if (proj.x < -50 || proj.x > 770 || proj.y < -50 || proj.y > 1330) {
                        this.bossProjectiles.splice(idx, 1);
                    }
                });

                // Spawn asteroids (INCREASED SIZE)
                const baseSpawnRate = 0.008;
                const maxSpawnRate = 0.025;
                const spawnRateIncrease = Math.min(this.state.gameTime / 120, 1);
                const currentSpawnRate = baseSpawnRate + (maxSpawnRate - baseSpawnRate) * spawnRateIncrease;
                
                if (Math.random() < currentSpawnRate) {
                    this.spawnAsteroid();
                }

                // Update bullets
                this.bullets = this.bullets.filter(b => {
                    b.y -= 15;
                    
                    if (b.ricochet && b.bounced) {
                        b.x += b.vx || 0;
                        b.y += b.vy || 0;
                    }
                    
                    return b.y > -20 && b.y < 1300 && b.x > 0 && b.x < 720;
                });

                // Update missiles
                this.missiles.forEach(missile => {
                    let target = missile.target;
                    if (this.boss && (!target || !this.asteroids.includes(target))) {
                        target = this.boss;
                    }
                    
                    if (target && (this.asteroids.includes(target) || target === this.boss)) {
                        const dx = target.x - missile.x;
                        const dy = target.y - missile.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Increased tracking strength from 0.3 to 0.5
                        missile.vx += (dx / dist) * 0.5;
                        missile.vy += (dy / dist) * 0.5;
                        
                        const speed = Math.sqrt(missile.vx * missile.vx + missile.vy * missile.vy);
                        // Increased max speed from 6 to 9
                        if (speed > 9) {
                            missile.vx = (missile.vx / speed) * 9;
                            missile.vy = (missile.vy / speed) * 9;
                        }
                    }
                    
                    missile.x += missile.vx;
                    missile.y += missile.vy;
                });

                // Update asteroids
                this.asteroids.forEach((a, i) => {
                    if (a.knockbackTime !== undefined) {
                        a.knockbackTime--;
                        if (a.knockbackTime <= 0) {
                            delete a.knockbackTime;
                            delete a.knockbackVx;
                            delete a.knockbackVy;
                        } else {
                            a.x += a.knockbackVx;
                            a.y += a.knockbackVy;
                        }
                    } else {
                        a.y += a.vy;
                        a.x += a.vx;
                    }
                    
                    a.rotation += a.rotSpeed;

                    // Wall collision with position clamping for symmetrical, accurate bouncing
                    if (a.x - a.size / 2 < 0) {
                        a.x = a.size / 2;
                        a.vx = Math.abs(a.vx);
                        if (a.knockbackVx !== undefined) a.knockbackVx = Math.abs(a.knockbackVx);
                    }
                    if (a.x + a.size / 2 > 720) {
                        a.x = 720 - a.size / 2;
                        a.vx = -Math.abs(a.vx);
                        if (a.knockbackVx !== undefined) a.knockbackVx = -Math.abs(a.knockbackVx);
                    }

                    // Player collision: skip entirely while invincible
                    if (this.checkCollision(this.player, a)) {
                        const isInvincible = this.player.invincible || Date.now() < this.player.invincibleUntil;
                        if (!isInvincible) {
                            this.takeDamage(1);
                            this.asteroids.splice(i, 1);
                        }
                    }

                    if (a.y > 1300) this.asteroids.splice(i, 1);
                });

                // Bullet-asteroid/boss collisions
                this.bullets.forEach((b, bi) => {
                    // Initialize hit tracking if not exists
                    if (!b.hitEntities) {
                        b.hitEntities = new Set();
                    }
                    
                    // Only apply piercing to main ship bullets, not support fighter bullets
                    const pierceTier = !b.fromFighter ? (this.player.skills.piercing_bullets || 0) : 0;
                    const maxPierce = pierceTier === 1 ? 2 : (pierceTier === 2 ? 5 : 1);
                    
                    let shouldRemoveBullet = false;
                    
                    // Check boss collision
                    if (this.boss && this.checkCollision(b, this.boss)) {
                        // Only damage if we haven't hit this boss yet
                        if (!b.hitEntities.has(this.boss)) {
                            const dmg = b.damage || this.player.damage;
                            const finalDmg = pierceTier === 2 && b.hitEntities.size === 0 ? dmg * 2 : dmg;
                            
                            this.boss.currentHp -= finalDmg;
                            this.updateBossHealthBar();
                            b.hitEntities.add(this.boss);
                            
                            // Only apply explosive to main ship bullets
                            const explosiveTier = !b.fromFighter ? (this.player.skills.explosive_bullets || 0) : 0;
                            if (explosiveTier > 0) {
                                this.createExplosion(b.x, b.y, explosiveTier);
                            }
                            
                            if (this.boss.currentHp <= 0) {
                                this.gainXP(500);
                                this.state.score += 1000;
                                this.state.coins += 50;
                                this.clearBossUI();
                                this.boss = null;
                                this.updateHUD();
                            }
                            
                            // Remove bullet if no piercing or hit max targets
                            if (pierceTier === 0 || b.hitEntities.size >= maxPierce) {
                                shouldRemoveBullet = true;
                            }
                        }
                    }
                    
                    // Check asteroid collisions
                    if (!shouldRemoveBullet) {
                        this.asteroids.forEach((a, ai) => {
                            if (this.checkCollision(b, a) && !b.hitEntities.has(a)) {
                                const dmg = b.damage || this.player.damage;
                                const finalDmg = pierceTier === 2 && b.hitEntities.size === 0 ? dmg * 2 : dmg;
                                
                                a.hp -= finalDmg;
                                b.hitEntities.add(a);
                                
                                // Only apply explosive to main ship bullets
                                const explosiveTier = !b.fromFighter ? (this.player.skills.explosive_bullets || 0) : 0;
                                if (explosiveTier > 0) {
                                    this.createExplosion(b.x, b.y, explosiveTier);
                                }
                                
                                // Only apply ricochet to main ship bullets
                                const ricochetTier = !b.fromFighter ? (this.player.skills.ricochet_bullets || 0) : 0;
                                if (ricochetTier > 0 && !b.bounced) {
                                    if (ricochetTier === 1) {
                                        b.bounced = true;
                                        const angle = Math.random() * Math.PI * 2;
                                        b.vx = Math.cos(angle) * 10;
                                        b.vy = Math.sin(angle) * 10;
                                        b.ricochet = true;
                                    } else {
                                        for (let i = 0; i < 2; i++) {
                                            const angle = Math.random() * Math.PI * 2;
                                            this.bullets.push({
                                                x: b.x,
                                                y: b.y,
                                                width: 6,
                                                height: 16,
                                                damage: dmg,
                                                vx: Math.cos(angle) * 8,
                                                vy: Math.sin(angle) * 8,
                                                bounced: true,
                                                ricochet: true
                                            });
                                        }
                                    }
                                }
                                
                                if (a.hp <= 0) {
                                    const rewards = this.getRewardsForAsteroid(a.tier);
                                    this.destroyAsteroid(a, ai);
                                    this.gainXP(10);
                                    this.state.score += rewards.stars;
                                    this.state.coins += rewards.coins;
                                    this.updateHUD();
                                }
                                
                                // Remove bullet if no piercing/ricochet or hit max targets
                                if ((pierceTier === 0 && ricochetTier === 0) || b.hitEntities.size >= maxPierce) {
                                    shouldRemoveBullet = true;
                                }
                            }
                        });
                    }
                    
                    // Remove bullet if marked for removal
                    if (shouldRemoveBullet) {
                        this.bullets.splice(bi, 1);
                    }
                });

                // Missile collisions
                this.missiles.forEach((m, mi) => {
                    if (this.boss && this.checkCollision(m, this.boss)) {
                        this.boss.currentHp -= this.player.damage * 1.5;
                        this.updateBossHealthBar();
                        
                        if (this.boss.currentHp <= 0) {
                            this.gainXP(500);
                            this.state.score += 1000;
                            this.state.coins += 50;
                            this.clearBossUI();
                            this.boss = null;
                            this.updateHUD();
                        }
                        
                        this.missiles.splice(mi, 1);
                        return;
                    }
                    
                    this.asteroids.forEach((a, ai) => {
                        if (this.checkCollision(m, a)) {
                            a.hp -= this.player.damage * 1.5;
                            
                            if (a.hp <= 0) {
                                const rewards = this.getRewardsForAsteroid(a.tier);
                                this.destroyAsteroid(a, ai);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                            
                            this.missiles.splice(mi, 1);
                        }
                    });
                });

                // Update explosions
                this.explosions = this.explosions.filter(exp => {
                    exp.time += 16;
                    return exp.time < exp.duration;
                });

                // Update lightning
                this.lightningBolts = this.lightningBolts.filter(bolt => {
                    bolt.time += 16;
                    return bolt.time < bolt.duration;
                });
            },

            activateChainLightning(tier) {
                const chainCount = tier === 1 ? 3 : 5;
                const damage = tier === 1 ? this.player.damage * 1.5 : this.player.damage * 1.75;
                const color = tier === 1 ? '#00ffff' : '#ff0066';
                
                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                targets = targets.sort((a, b) => {
                    const distA = Math.sqrt((a.x - this.player.x) ** 2 + (a.y - this.player.y) ** 2);
                    const distB = Math.sqrt((b.x - this.player.x) ** 2 + (b.y - this.player.y) ** 2);
                    return distA - distB;
                }).slice(0, chainCount);

                let prev = { x: this.player.x, y: this.player.y };
                targets.forEach(target => {
                    this.lightningBolts.push({
                        x1: prev.x,
                        y1: prev.y,
                        x2: target.x,
                        y2: target.y,
                        color: color,
                        time: 0,
                        duration: 500
                    });
                    
                    if (target === this.boss) {
                        this.boss.currentHp -= damage;
                        this.updateBossHealthBar();
                        if (this.boss.currentHp <= 0) {
                            this.gainXP(500);
                            this.state.score += 1000;
                            this.state.coins += 50;
                            this.clearBossUI();
                            this.boss = null;
                            this.updateHUD();
                        }
                    } else {
                        target.hp -= damage;
                        if (target.hp <= 0) {
                            const idx = this.asteroids.indexOf(target);
                            if (idx !== -1) {
                                const rewards = this.getRewardsForAsteroid(target.tier);
                                this.destroyAsteroid(target, idx);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                        }
                    }
                    
                    prev = target;
                });
            },

            launchMissiles(tier) {
                const count = tier === 1 ? 1 : 3;
                let targets = [...this.asteroids];
                if (this.boss) targets = [this.boss, ...targets];
                
                targets = targets.sort((a, b) => {
                    const distA = Math.sqrt((a.x - this.player.x) ** 2 + (a.y - this.player.y) ** 2);
                    const distB = Math.sqrt((b.x - this.player.x) ** 2 + (b.y - this.player.y) ** 2);
                    return distA - distB;
                }).slice(0, count);

                targets.forEach(target => {
                    this.missiles.push({
                        x: this.player.x,
                        y: this.player.y - 30,
                        vx: 0,
                        vy: -3,
                        target: target,
                        size: 8
                    });
                });
            },

            applyLaserDamage(ship, tier) {
                const damage = tier === 1 ? 14 : 20;
                const laserY = ship.y;
                const laserThickness = 15;
                
                // Damage tick rate control - only apply damage every 200ms instead of every frame
                const now = Date.now();
                const damageCooldown = 200; // milliseconds between damage ticks
                
                if (now - ship.lastDamageTick < damageCooldown) {
                    return; // Skip damage application this frame
                }
                
                ship.lastDamageTick = now;

                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                // Sort targets by distance from turret to find closest target first
                targets = targets.sort((a, b) => {
                    if (tier === 1) {
                        // Left turret - sort by x position (closest to turret first)
                        return a.x - b.x;
                    } else {
                        // Right turret - sort by x position (closest to turret first)
                        return b.x - a.x;
                    }
                });
                
                // Only damage the FIRST target hit (no piercing)
                for (let target of targets) {
                    // Check if target is within the horizontal beam's vertical range
                    const targetSize = target.size || target.width || 50;
                    const verticalDist = Math.abs(target.y - laserY);
                    
                    if (verticalDist < laserThickness / 2 + targetSize / 2) {
                        // Check if target is in the beam's horizontal path
                        let inBeamPath = false;
                        if (tier === 1) {
                            // Left turret fires to the right
                            inBeamPath = target.x >= ship.x;
                        } else {
                            // Right turret fires to the left
                            inBeamPath = target.x <= ship.x;
                        }

                        if (inBeamPath) {
                            // This is the first target in the beam path - damage it and stop
                            if (target === this.boss) {
                                this.boss.currentHp -= damage;
                                this.updateBossHealthBar();
                                if (this.boss.currentHp <= 0) {
                                    this.gainXP(500);
                                    this.state.score += 1000;
                                    this.state.coins += 50;
                                    this.clearBossUI(); // Clear all boss UI
                                    this.boss = null;
                                    this.updateHUD();
                                }
                            } else {
                                target.hp -= damage;
                                if (target.hp <= 0) {
                                    const rewards = this.getRewardsForAsteroid(target.tier);
                                    const targetIndex = this.asteroids.indexOf(target);
                                    if (targetIndex !== -1) {
                                        this.destroyAsteroid(target, targetIndex);
                                    }
                                    this.gainXP(10);
                                    this.state.score += rewards.stars;
                                    this.state.coins += rewards.coins;
                                    this.updateHUD();
                                }
                            }
                            // Stop after hitting first target (no piercing)
                            break;
                        }
                    }
                }
            },

            isHorizontalLaserBlocked(ship, targetEntity, tier) {
                // Check if any entity blocks the horizontal laser path
                let entities = [...this.asteroids];
                if (this.boss && this.boss !== targetEntity) entities.push(this.boss);
                
                const laserY = ship.y;
                const laserThickness = 15;
                
                for (let entity of entities) {
                    if (entity === targetEntity) continue;
                    
                    const entitySize = entity.size || entity.width || 50;
                    const verticalDist = Math.abs(entity.y - laserY);
                    
                    // Check if blocking entity is in the vertical range of the beam
                    if (verticalDist < laserThickness / 2 + entitySize / 2) {
                        // Check if blocking entity is between turret and target
                        if (tier === 1) {
                            // Left turret: blocker must be between turret and target
                            if (entity.x > ship.x && entity.x < targetEntity.x) {
                                return true;
                            }
                        } else {
                            // Right turret: blocker must be between target and turret
                            if (entity.x < ship.x && entity.x > targetEntity.x) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            },

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                const param = lenSq !== 0 ? dot / lenSq : -1;
                
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },

            createExplosion(x, y, tier) {
                const radius = tier === 1 ? 50 : 80;
                const damage = tier === 1 ? this.player.damage : this.player.damage * 2;
                
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: radius,
                    maxRadius: tier === 1 ? 60 : 100,
                    time: 0,
                    duration: tier === 1 ? 300 : 400
                });
                
                let targets = [...this.asteroids];
                if (this.boss) targets.push(this.boss);
                
                targets.forEach((target, idx) => {
                    const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
                    if (dist < radius) {
                        if (target === this.boss) {
                            this.boss.currentHp -= damage;
                            this.updateBossHealthBar();
                            if (this.boss.currentHp <= 0) {
                                this.gainXP(500);
                                this.state.score += 1000;
                                this.state.coins += 50;
                                this.clearBossUI();
                                this.boss = null;
                                this.updateHUD();
                            }
                        } else {
                            target.hp -= damage;
                            if (target.hp <= 0) {
                                const rewards = this.getRewardsForAsteroid(target.tier);
                                this.destroyAsteroid(target, idx);
                                this.gainXP(10);
                                this.state.score += rewards.stars;
                                this.state.coins += rewards.coins;
                                this.updateHUD();
                            }
                        }
                    }
                });
            },

            destroyAsteroid(asteroid, index) {
                this.asteroids.splice(index, 1);

                if (asteroid.tier !== 'small') {
                    const nextTier = this.getNextTier(asteroid.tier);
                    const nextSize = this.getSizeForTier(nextTier);
                    const nextHP = this.getHPForTier(nextTier);

                    for (let i = 0; i < 2; i++) {
                        const horizontalDirection = (i === 0 ? -1 : 1);
                        const horizontalSpeed = 2 + Math.random() * 1.5;
                        const baseDownwardVelocity = Math.max(asteroid.vy, 1.5);
                        const downwardSpeed = baseDownwardVelocity + Math.random() * 0.5;

                        this.asteroids.push({
                            x: asteroid.x + horizontalDirection * 20,
                            y: asteroid.y,
                            size: nextSize,
                            hp: nextHP,
                            tier: nextTier,
                            vx: horizontalDirection * horizontalSpeed,
                            vy: downwardSpeed,
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.08,
                            color: asteroid.color,
                            vertices: this.generatePolygon(nextSize)
                        });
                    }
                }
            },

            getNextTier(currentTier) {
                const tiers = {
                    'veryLarge': 'large',
                    'large': 'medium',
                    'medium': 'small',
                    'small': null
                };
                return tiers[currentTier];
            },

            getSizeForTier(tier) {
                // INCREASED SIZE (multiplied by 1.5)
                const sizes = {
                    'veryLarge': 180,
                    'large': 127,
                    'medium': 82,
                    'small': 45
                };
                return sizes[tier];
            },

            getHPForTier(tier) {
                const baseHPs = {
                    'veryLarge': 80,
                    'large': 40,
                    'medium': 20,
                    'small': 10
                };
                
                // HP scales gradually with game time (every 60 seconds increases HP by 8%)
                const timeMinutes = this.state.gameTime / 60;
                const scalingFactor = 1 + (timeMinutes * 0.08);
                
                return Math.floor(baseHPs[tier] * scalingFactor);
            },

            getRewardsForAsteroid(tier) {
                const maxHP = this.getHPForTier(tier);
                return {
                    coins: Math.floor(maxHP * 0.1), // 10% of HP
                    stars: Math.floor(maxHP * 0.01) || 1 // 1% of HP, minimum 1
                };
            },

            shoot() {
                this.bullets.push({
                    x: this.player.x,
                    y: this.player.y - 30,
                    width: 8,
                    height: 20,
                    damage: this.player.damage
                });
            },

            spawnAsteroid() {
                const tierWeights = [
                    { tier: 'veryLarge', weight: 0.3 },
                    { tier: 'large', weight: 0.35 },
                    { tier: 'medium', weight: 0.25 },
                    { tier: 'small', weight: 0.1 }
                ];

                let rand = Math.random();
                let selectedTier = 'medium';
                let cumulative = 0;
                
                for (const tw of tierWeights) {
                    cumulative += tw.weight;
                    if (rand <= cumulative) {
                        selectedTier = tw.tier;
                        break;
                    }
                }

                const size = this.getSizeForTier(selectedTier);
                const hp = this.getHPForTier(selectedTier);
                const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ff8800', '#8800ff', '#ffff00', '#ff0088', '#00ff88'];

                this.asteroids.push({
                    x: Math.random() * 720,
                    y: -100,
                    size: size,
                    hp: hp,
                    tier: selectedTier,
                    vx: (Math.random() - 0.5) * 2,
                    vy: 1 + Math.random() * 2,
                    rotation: 0,
                    rotSpeed: (Math.random() - 0.5) * 0.05,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    vertices: this.generatePolygon(size)
                });
            },

            generatePolygon(size) {
                const vertices = [];
                const count = 6 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = size / 2 * (0.8 + Math.random() * 0.4);
                    vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                return vertices;
            },

            checkCollision(a, b) {
                const r1 = a.width ? Math.max(a.width, a.height) / 2 : (a.size || 5);
                const r2 = b.width ? Math.max(b.width, b.height) / 2 : (b.size ? b.size / 2 : 5);
                const dist = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
                return dist < r1 + r2;
            },

            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.renderParallaxStars();

                // Render damage flash (red screen edge border)
                const now = Date.now();
                if (now < this.player.damageFlashUntil) {
                    const flashAlpha = (this.player.damageFlashUntil - now) / 1000; // Fade out over 1 second
                    this.ctx.strokeStyle = `rgba(255, 0, 0, ${flashAlpha * 0.8})`;
                    this.ctx.lineWidth = 20;
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = `rgba(255, 0, 0, ${flashAlpha})`;
                    this.ctx.strokeRect(10, 10, this.canvas.width - 20, this.canvas.height - 20);
                    this.ctx.shadowBlur = 0;
                }

                // Render horizontal laser beams (stops at first target)
                this.laserShips.forEach(ship => {
                    if (ship.active) {
                        const laserY = ship.y;
                        const beamThickness = 15;
                        const tier = this.player.skills.laser_fortress || 0;
                        
                        // Find first target in laser path
                        let targets = [...this.asteroids];
                        if (this.boss) targets.push(this.boss);
                        
                        // Sort targets by distance from turret
                        targets = targets.sort((a, b) => {
                            if (tier === 1) {
                                return a.x - b.x; // Left turret, sort left to right
                            } else {
                                return b.x - a.x; // Right turret, sort right to left
                            }
                        });
                        
                        // Find first target hit
                        let endX = tier === 1 ? this.canvas.width : 0;
                        for (let target of targets) {
                            const targetSize = target.size || target.width || 50;
                            const verticalDist = Math.abs(target.y - laserY);
                            
                            if (verticalDist < beamThickness / 2 + targetSize / 2) {
                                let inBeamPath = false;
                                if (tier === 1) {
                                    inBeamPath = target.x >= ship.x;
                                } else {
                                    inBeamPath = target.x <= ship.x;
                                }
                                
                                if (inBeamPath) {
                                    endX = target.x;
                                    break;
                                }
                            }
                        }
                        
                        if (tier === 2) {
                            // Level 2: Red beam with white borders, fires to the left
                            // White borders
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = beamThickness + 6;
                            this.ctx.globalAlpha = 0.6;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#ffffff';
                            this.ctx.beginPath();
                            this.ctx.moveTo(endX, laserY);
                            this.ctx.lineTo(ship.x, laserY);
                            this.ctx.stroke();
                            
                            // Red main beam
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.lineWidth = beamThickness;
                            this.ctx.shadowColor = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.moveTo(endX, laserY);
                            this.ctx.lineTo(ship.x, laserY);
                            this.ctx.stroke();
                        } else {
                            // Level 1: Standard red beam, fires to the right
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.lineWidth = beamThickness;
                            this.ctx.globalAlpha = 0.6;
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.moveTo(ship.x, laserY);
                            this.ctx.lineTo(endX, laserY);
                            this.ctx.stroke();
                        }
                        
                        this.ctx.globalAlpha = 1;
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Render laser turrets with image override support
                const laserScale = IMAGE_SCALES.laserFortress ? IMAGE_SCALES.laserFortress / 100 : 1;
                this.laserShips.forEach(ship => {
                    const tier = this.player.skills.laser_fortress || 0;
                    const imageKey = tier === 1 ? 'laserFortressL1' : 'laserFortressL2';
                    const img = this.loadedImages[imageKey];
                    
                    if (img) {
                        // Use custom image with optional scale (visual only, hitbox unchanged)
                        this.ctx.save();
                        this.ctx.translate(ship.x, ship.y);
                        const scaledSize = 40 * laserScale;
                        this.ctx.drawImage(img, -scaledSize/2, -scaledSize/2, scaledSize, scaledSize);
                        this.ctx.restore();
                    } else {
                        // Default visual with optional scale
                        this.ctx.save();
                        this.ctx.translate(ship.x, ship.y);
                        this.ctx.scale(laserScale, laserScale);
                        this.ctx.fillStyle = ship.active ? '#ff0000' : '#666';
                        this.ctx.shadowBlur = ship.active ? 15 : 0;
                        this.ctx.shadowColor = '#ff0000';
                        this.ctx.fillRect(-20, -20, 40, 40);
                        this.ctx.shadowBlur = 0;
                        this.ctx.restore();
                    }
                });

                // Render boss laser sweep
                if (this.boss && this.boss.laserSweep && this.boss.laserSweep.active) {
                    const angle = this.boss.laserSweep.angle;
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 10;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.boss.x, this.boss.y);
                    this.ctx.lineTo(
                        this.boss.x + Math.cos(angle) * 1000,
                        this.boss.y + Math.sin(angle) * 1000
                    );
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }

                // Render boss projectiles
                this.bossProjectiles.forEach(proj => {
                    if (proj.ring) {
                        this.ctx.strokeStyle = proj.color;
                        this.ctx.lineWidth = 5;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = proj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                    } else {
                        this.ctx.fillStyle = proj.color;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = proj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Render boss with image override support
                if (this.boss) {
                    // Check for custom boss image
                    const bossImageKey = `boss${['flame_demon', 'void_kraken', 'cyber_skull'].indexOf(this.boss.id) + 1}`;
                    const bossImg = this.loadedImages[bossImageKey];
                    
                    this.ctx.save();
                    this.ctx.translate(this.boss.x, this.boss.y);
                    
                    if (bossImg) {
                        // Use custom image for boss
                        const size = this.boss.size * 2;
                        this.ctx.drawImage(bossImg, -size/2, -size/2, size, size);
                    } else {
                        // Draw boss based on type (default visuals)
                        if (this.boss.id === 'flame_demon') {
                            // Flame demon - skull shape
                            this.ctx.fillStyle = this.boss.color;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            this.ctx.beginPath();
                            this.ctx.arc(0, -20, 50, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.fillRect(-30, 10, 60, 40);
                            
                            // Eyes
                            this.ctx.fillStyle = '#000';
                            this.ctx.beginPath();
                            this.ctx.arc(-20, -20, 10, 0, Math.PI * 2);
                            this.ctx.arc(20, -20, 10, 0, Math.PI * 2);
                            this.ctx.fill();
                        } else if (this.boss.id === 'void_kraken') {
                            // Void kraken - tentacle creature
                            this.ctx.fillStyle = this.boss.color;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 60, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Tentacles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                this.ctx.beginPath();
                                this.ctx.moveTo(0, 0);
                                this.ctx.lineTo(Math.cos(angle) * 80, Math.sin(angle) * 80);
                                this.ctx.lineWidth = 15;
                                this.ctx.strokeStyle = this.boss.color;
                                this.ctx.stroke();
                            }
                        } else if (this.boss.id === 'cyber_skull') {
                            // Cyber skull - geometric
                            this.ctx.strokeStyle = this.boss.color;
                            this.ctx.fillStyle = this.boss.color + '44';
                            this.ctx.lineWidth = 4;
                            this.ctx.shadowBlur = 30;
                            this.ctx.shadowColor = this.boss.color;
                            
                            // Hexagon
                            this.ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const x = Math.cos(angle) * 60;
                                const y = Math.sin(angle) * 60;
                                if (i === 0) this.ctx.moveTo(x, y);
                                else this.ctx.lineTo(x, y);
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // Inner circle
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 30, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                    
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                }

                // Render asteroids
                this.asteroids.forEach(a => {
                    this.ctx.save();
                    this.ctx.translate(a.x, a.y);
                    this.ctx.rotate(a.rotation);
                    this.ctx.beginPath();
                    a.vertices.forEach((v, i) => {
                        if (i === 0) this.ctx.moveTo(v.x, v.y);
                        else this.ctx.lineTo(v.x, v.y);
                    });
                    this.ctx.closePath();
                    this.ctx.fillStyle = a.color + '33';
                    this.ctx.fill();
                    this.ctx.strokeStyle = a.color;
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = a.color;
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = `bold ${a.size * 0.3}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(Math.ceil(a.hp), a.x, a.y);
                });

                // Render player with image override support
                const playerImg = this.loadedImages['playerShip'];
                const playerScale = IMAGE_SCALES.playerShip ? IMAGE_SCALES.playerShip / 100 : 1;
                const isInvincible = now < this.player.invincibleUntil;
                const shouldBlink = isInvincible && Math.floor(now / 100) % 2 === 0; // Blink every 100ms
                
                if (!shouldBlink) { // Only render if not blinking off
                    this.ctx.save();
                    this.ctx.translate(this.player.x, this.player.y);
                    
                    if (playerImg) {
                        // Use custom image with optional scale (visual only, hitbox unchanged)
                        const scaledWidth = 60 * playerScale;
                        const scaledHeight = 90 * playerScale;
                        this.ctx.drawImage(playerImg, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                    } else {
                        // Default visual with optional scale
                        this.ctx.scale(playerScale, playerScale);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -30);
                        this.ctx.lineTo(-20, 30);
                        this.ctx.lineTo(0, 20);
                        this.ctx.lineTo(20, 30);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.restore();
                }

                // Render support fighters with image override support
                const supportImg = this.loadedImages['supportShip'];
                const supportScale = IMAGE_SCALES.supportShip ? IMAGE_SCALES.supportShip / 100 : 1;
                
                if (!shouldBlink) { // Only render if not blinking off (same as player)
                    this.supportFighters.forEach(fighter => {
                        const x = this.player.x + fighter.offsetX;
                        const y = this.player.y + fighter.offsetY;
                        this.ctx.save();
                        this.ctx.translate(x, y);
                        
                        if (supportImg) {
                            // Use custom image with optional scale (visual only, hitbox unchanged)
                            const scaledWidth = 30 * supportScale;
                            const scaledHeight = 45 * supportScale;
                            this.ctx.drawImage(supportImg, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                        } else {
                            // Default visual with optional scale
                            this.ctx.scale(supportScale, supportScale);
                            this.ctx.fillStyle = '#00ffff';
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = '#00ffff';
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -15);
                            this.ctx.lineTo(-10, 15);
                            this.ctx.lineTo(0, 10);
                            this.ctx.lineTo(10, 15);
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                        }
                        this.ctx.restore();
                    });
                }

                // Render bullets
                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.fromFighter ? '#00ffff' : '#00ff00';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = b.fromFighter ? '#00ffff' : '#00ff00';
                    this.ctx.fillRect(b.x - 4, b.y - 10, 8, 20);
                    this.ctx.shadowBlur = 0;
                });

                // Render missiles
                this.missiles.forEach(m => {
                    this.ctx.save();
                    this.ctx.translate(m.x, m.y);
                    
                    // Calculate angle based on velocity
                    const angle = Math.atan2(m.vy, m.vx) + Math.PI / 2;
                    this.ctx.rotate(angle);
                    
                    // Red bottom triangle
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -12);
                    this.ctx.lineTo(-8, 8);
                    this.ctx.lineTo(8, 8);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // White top triangle (smaller)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -10);
                    this.ctx.lineTo(-5, 5);
                    this.ctx.lineTo(5, 5);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                    
                    // Spark effects trail
                    if (Math.random() < 0.5) {
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.globalAlpha = 0.7;
                        const sparkX = m.x - m.vx * 0.5 + (Math.random() - 0.5) * 5;
                        const sparkY = m.y - m.vy * 0.5 + (Math.random() - 0.5) * 5;
                        this.ctx.fillRect(sparkX, sparkY, 2, 2);
                        this.ctx.globalAlpha = 1;
                    }
                });

                // Render explosions
                this.explosions.forEach(exp => {
                    const progress = exp.time / exp.duration;
                    const currentRadius = exp.radius + (exp.maxRadius - exp.radius) * progress;
                    const alpha = 1 - progress;
                    
                    this.ctx.strokeStyle = `rgba(255, 102, 0, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#ff6600';
                    this.ctx.beginPath();
                    this.ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                });

                // Render lightning with improved visuals
                this.lightningBolts.forEach(bolt => {
                    const alpha = 1 - (bolt.time / bolt.duration);
                    
                    // Draw outer glow
                    this.ctx.strokeStyle = bolt.color;
                    this.ctx.lineWidth = 12;
                    this.ctx.globalAlpha = alpha * 0.3;
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = bolt.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.x1, bolt.y1);
                    this.ctx.lineTo(bolt.x2, bolt.y2);
                    this.ctx.stroke();
                    
                    // Draw main bolt
                    this.ctx.strokeStyle = bolt.color;
                    this.ctx.lineWidth = 6;
                    this.ctx.globalAlpha = alpha * 0.8;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = bolt.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.x1, bolt.y1);
                    this.ctx.lineTo(bolt.x2, bolt.y2);
                    this.ctx.stroke();
                    
                    // Draw bright core
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(bolt.x1, bolt.y1);
                    this.ctx.lineTo(bolt.x2, bolt.y2);
                    this.ctx.stroke();
                    
                    this.ctx.shadowBlur = 0;
                    this.ctx.globalAlpha = 1;
                });
            },

            renderParallaxStars() {
                this.starLayers.forEach(layer => {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${layer.opacity})`;
                    layer.stars.forEach(star => {
                        star.y += layer.speed;
                        if (star.y > 1280) {
                            star.y = 0;
                            star.x = Math.random() * 720;
                        }
                        this.ctx.fillRect(star.x, star.y, layer.size, layer.size);
                    });
                });
            },

            gameOver() {
                this.state.running = false;
                this.clearBossUI();
                document.getElementById('touchLayer').classList.remove('active');
                document.getElementById('pauseBtn').classList.remove('active');
                document.getElementById('finalScore').textContent = this.state.score;
                document.getElementById('gameOverScreen').classList.add('active');
            },

            restart() {
                document.getElementById('gameOverScreen').classList.remove('active');
                this.startGame();
            },

            backToMenu() {
                document.getElementById('gameOverScreen').classList.remove('active');
                this.clearBossUI();
                this.showMainMenu();
            }
        };

        game.init();
    </script>
</body>
</html>