<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Strike - Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 900px;
            height: 700px;
            background: #000;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            background: rgba(0, 0, 0, 0.95);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .overlay.active {
            display: flex;
        }

        .menu {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            color: #fff;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        h2 {
            color: #fff;
            font-size: 32px;
            margin-bottom: 20px;
        }

        h3 {
            color: #4facfe;
            font-size: 20px;
            margin: 15px 0 10px 0;
        }

        .btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(245, 87, 108, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .btn-small {
            padding: 10px 20px;
            font-size: 14px;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 5;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .hearts {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .heart {
            width: 30px;
            height: 30px;
            background: #ff4757;
            transform: rotate(-45deg);
            position: relative;
        }

        .heart::before,
        .heart::after {
            content: '';
            width: 30px;
            height: 30px;
            background: #ff4757;
            border-radius: 50%;
            position: absolute;
        }

        .heart::before {
            top: -15px;
            left: 0;
        }

        .heart::after {
            left: 15px;
            top: 0;
        }

        .xp-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #4facfe;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            transition: width 0.3s;
        }

        .upgrade-cards {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .card {
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border: 3px solid rgba(79, 172, 254, 0.5);
            border-radius: 15px;
            padding: 20px;
            width: 220px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #4facfe;
            box-shadow: 0 15px 40px rgba(79, 172, 254, 0.6);
        }

        .card.fusion {
            border-color: #9b59b6;
            background: rgba(155, 89, 182, 0.1);
        }

        .card.fusion:hover {
            border-color: #e74c3c;
            box-shadow: 0 15px 40px rgba(231, 76, 60, 0.6);
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .card-title {
            color: #4facfe;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .card.fusion .card-title {
            color: #e74c3c;
        }

        .card-desc {
            color: #fff;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .card-tier {
            color: #ffd700;
            font-size: 12px;
            font-weight: bold;
            margin-top: 10px;
        }

        .card-stats {
            color: #4facfe;
            font-size: 13px;
            margin-top: 10px;
            text-align: left;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
        }

        .stat-name {
            color: #4facfe;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .lang-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }

        .currency {
            color: #ffd700;
            font-size: 20px;
            margin-top: 10px;
        }

        .stage-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stage-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .stage-card:hover {
            transform: translateY(-5px);
            border-color: #4facfe;
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.3);
        }

        .stage-number {
            font-size: 32px;
            color: #4facfe;
            font-weight: bold;
        }

        .stage-difficulty {
            color: #ffd700;
            margin: 5px 0;
        }

        .upgrade-tree {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 600px;
            margin: 20px auto;
        }

        .tree-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .tree-node {
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 15px;
            width: 150px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tree-node:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(79, 172, 254, 0.4);
        }

        .tree-node.locked {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
        }

        .tree-node.purchased {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
        }

        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff4757;
            font-weight: bold;
            text-shadow: 0 0 20px #ff4757;
            z-index: 8;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .timer {
            color: #4facfe;
            font-size: 18px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="lang-selector">
            <select id="langSelect" class="btn btn-small">
                <option value="en">English</option>
                <option value="vi">Ti·∫øng Vi·ªát</option>
            </select>
        </div>

        <canvas id="gameCanvas" width="900" height="700"></canvas>
        
        <div class="hud">
            <div class="hearts" id="heartsDisplay"></div>
            <div style="margin-top: 10px;">
                <div id="levelText">Level: 1</div>
                <div class="xp-bar">
                    <div class="xp-fill" id="xpFill" style="width: 0%"></div>
                </div>
            </div>
            <div class="currency" id="currencyDisplay">üíé 0</div>
            <div class="timer" id="timerDisplay">Time: 0:00</div>
        </div>

        <div id="bossWarning" style="display: none;" class="boss-warning">‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è</div>

        <!-- Main Menu -->
        <div id="mainMenu" class="overlay active">
            <div class="menu">
                <h1 id="gameTitle">üöÄ ASTEROID STRIKE üöÄ</h1>
                <p style="color: #fff; margin-bottom: 30px;" id="gameSubtitle">Ultimate Edition</p>
                <button class="btn" onclick="startGame('endless')" id="btnEndless">Endless Mode</button>
                <button class="btn" onclick="showStageSelect()" id="btnStage">Stage Mode</button>
                <button class="btn btn-secondary" onclick="showUpgrades()" id="btnUpgrades">Upgrades</button>
                <button class="btn btn-secondary" onclick="showUpgradeTree()" id="btnTree">Upgrade Tree</button>
            </div>
        </div>

        <!-- Stage Selection -->
        <div id="stageSelect" class="overlay">
            <div class="menu">
                <h2 id="stageSelectTitle">SELECT STAGE</h2>
                <div class="stage-list" id="stageList"></div>
                <button class="btn" onclick="hideStageSelect()" id="btnBackStage">Back</button>
            </div>
        </div>

        <!-- Level Up Menu -->
        <div id="levelUpMenu" class="overlay">
            <div class="menu">
                <h2 id="levelUpTitle">‚ö° LEVEL UP! ‚ö°</h2>
                <p style="color: #fff; margin-bottom: 10px;" id="chooseUpgrade">Choose an upgrade:</p>
                <div class="upgrade-cards" id="upgradeCards"></div>
            </div>
        </div>

        <!-- Game Over Menu -->
        <div id="gameOverMenu" class="overlay">
            <div class="menu">
                <h2 id="gameOverTitle">GAME OVER</h2>
                <p style="color: #fff; font-size: 24px; margin: 20px 0;" id="scoreText">Score: <span id="finalScore">0</span></p>
                <p style="color: #ffd700; font-size: 20px; margin: 10px 0;" id="earnedText">Earned: <span id="earnedCurrency">0</span> üíé</p>
                <button class="btn" onclick="showMainMenu()" id="btnMainMenu">Main Menu</button>
                <button class="btn btn-secondary" onclick="restartGame()" id="btnRestart">Restart</button>
            </div>
        </div>

        <!-- Upgrades Menu -->
        <div id="upgradesMenu" class="overlay">
            <div class="menu" style="max-width: 700px;">
                <h2 id="upgradesTitle">PERMANENT UPGRADES</h2>
                <div class="currency" id="upgradeCurrency" style="margin-bottom: 20px;">üíé 0</div>
                <div class="stats-grid" id="upgradeStats"></div>
                <button class="btn" onclick="hideUpgrades()" id="btnBack">Back</button>
            </div>
        </div>

        <!-- Upgrade Tree -->
        <div id="upgradeTreeMenu" class="overlay">
            <div class="menu" style="max-width: 800px;">
                <h2 id="treeTitle">UPGRADE TREE</h2>
                <div class="currency" id="treeCurrency" style="margin-bottom: 20px;">üíé 0</div>
                <div class="upgrade-tree" id="upgradeTreeContainer"></div>
                <button class="btn" onclick="hideUpgradeTree()" id="btnBackTree">Back</button>
            </div>
        </div>
    </div>

    <script>
        // Stage Configuration System
        const STAGE_CONFIG = {
            1: {
                name: "Tutorial",
                difficulty: "Easy",
                duration: 120, // seconds
                spawnRate: 0.015,
                asteroidHPMultiplier: 1.0,
                bossCount: 0,
                rewards: 50
            },
            2: {
                name: "Asteroid Field",
                difficulty: "Normal",
                duration: 180,
                spawnRate: 0.02,
                asteroidHPMultiplier: 1.2,
                bossCount: 1,
                bossSpawnTimes: [150],
                rewards: 100
            },
            3: {
                name: "Heavy Combat",
                difficulty: "Hard",
                duration: 240,
                spawnRate: 0.025,
                asteroidHPMultiplier: 1.5,
                bossCount: 2,
                bossSpawnTimes: [120, 210],
                rewards: 150
            },
            4: {
                name: "Chaos Zone",
                difficulty: "Very Hard",
                duration: 300,
                spawnRate: 0.03,
                asteroidHPMultiplier: 2.0,
                bossCount: 3,
                bossSpawnTimes: [100, 180, 260],
                rewards: 250
            }
        };

        // Language System
        const translations = {
            en: {
                gameTitle: "üöÄ ASTEROID STRIKE üöÄ",
                gameSubtitle: "Ultimate Edition",
                btnEndless: "Endless Mode",
                btnStage: "Stage Mode",
                btnUpgrades: "Upgrades",
                btnTree: "Upgrade Tree",
                levelUpTitle: "‚ö° LEVEL UP! ‚ö°",
                chooseUpgrade: "Choose an upgrade:",
                gameOverTitle: "GAME OVER",
                scoreText: "Score:",
                earnedText: "Earned:",
                btnMainMenu: "Main Menu",
                btnRestart: "Restart",
                upgradesTitle: "PERMANENT UPGRADES",
                treeTitle: "UPGRADE TREE",
                btnBack: "Back",
                btnBackStage: "Back",
                btnBackTree: "Back",
                level: "Level:",
                time: "Time:",
                stageSelectTitle: "SELECT STAGE",
                // Skills
                homing: "Homing Missile",
                homingDesc: "Launch heat-seeking missiles",
                bulletCount: "Multi-Stream",
                bulletCountDesc: "Fire multiple bullet streams",
                explosion: "Explosive Rounds",
                explosionDesc: "Bullets explode on impact",
                electric: "Electric Chain",
                electricDesc: "Lightning that chains enemies",
                laserDrop: "Laser Cannon",
                laserDropDesc: "Deploy laser turrets",
                ricochet: "Ricochet Bullets",
                ricochetDesc: "Bullets bounce between enemies",
                pierce: "Armor Piercing",
                pierceDesc: "Bullets pierce through targets",
                // Fusions
                homingExplosion: "Nova Missiles",
                homingExplosionDesc: "Homing missiles that explode",
                homingRicochet: "Chain Missiles",
                homingRicochetDesc: "Missiles that jump targets",
                bulletRicochet: "Cannon Barrage",
                bulletRicochetDesc: "Side cannons with bouncing shots",
                bulletPierce: "Railgun Array",
                bulletPierceDesc: "Devastating piercing streams",
                explosionElectric: "Plasma Storm",
                explosionElectricDesc: "Electric explosions",
                laserPierce: "Penetrator Beam",
                laserPierceDesc: "Unstoppable laser",
                laserRicochet: "Laser Grid",
                laserRicochetDesc: "Interlocking laser network",
                laserElectric: "Tesla Turrets",
                laserElectricDesc: "Electric laser pulses",
                // Stats
                damage: "Damage",
                attackSpeed: "Attack Speed",
                maxHearts: "Max Hearts",
                critRate: "Critical Rate",
                tier1: "TIER 1",
                tier2: "TIER 2",
                tier3: "TIER 3 - FUSION",
                cost: "Cost:",
                stage: "Stage",
                difficulty: "Difficulty:",
                rewards: "Rewards:",
                boss: "Boss:",
                yes: "Yes",
                no: "No"
            },
            vi: {
                gameTitle: "üöÄ THI√äN TH·∫†CH T·∫§N C√îNG üöÄ",
                gameSubtitle: "Phi√™n B·∫£n T·ªëi Th∆∞·ª£ng",
                btnEndless: "Ch·∫ø ƒê·ªô V√¥ T·∫≠n",
                btnStage: "Ch·∫ø ƒê·ªô M√†n Ch∆°i",
                btnUpgrades: "N√¢ng C·∫•p",
                btnTree: "C√¢y N√¢ng C·∫•p",
                levelUpTitle: "‚ö° TƒÇNG C·∫§P! ‚ö°",
                chooseUpgrade: "Ch·ªçn n√¢ng c·∫•p:",
                gameOverTitle: "K·∫æT TH√öC",
                scoreText: "ƒêi·ªÉm:",
                earnedText: "Nh·∫≠n:",
                btnMainMenu: "Menu Ch√≠nh",
                btnRestart: "Ch∆°i L·∫°i",
                upgradesTitle: "N√ÇNG C·∫§P Vƒ®NH VI·ªÑN",
                treeTitle: "C√ÇY N√ÇNG C·∫§P",
                btnBack: "Quay L·∫°i",
                btnBackStage: "Quay L·∫°i",
                btnBackTree: "Quay L·∫°i",
                level: "C·∫•p:",
                time: "Th·ªùi gian:",
                stageSelectTitle: "CH·ªåN M√ÄN CH∆†I",
                homing: "T√™n L·ª≠a D·∫´n",
                homingDesc: "Ph√≥ng t√™n l·ª≠a t·ª± d√≤",
                bulletCount: "ƒêa D√≤ng",
                bulletCountDesc: "B·∫Øn nhi·ªÅu d√≤ng ƒë·∫°n",
                explosion: "ƒê·∫°n N·ªï",
                explosionDesc: "ƒê·∫°n n·ªï khi va ch·∫°m",
                electric: "X√≠ch ƒêi·ªán",
                electricDesc: "S√©t x√≠ch gi·ªØa k·∫ª th√π",
                laserDrop: "Ph√°o Laser",
                laserDropDesc: "Tri·ªÉn khai ph√°o ƒë√†i",
                ricochet: "ƒê·∫°n B·∫≠t",
                ricochetDesc: "ƒê·∫°n n·∫£y gi·ªØa m·ª•c ti√™u",
                pierce: "Xuy√™n Gi√°p",
                pierceDesc: "ƒê·∫°n xuy√™n qua m·ª•c ti√™u",
                homingExplosion: "T√™n L·ª≠a Nova",
                homingExplosionDesc: "T√™n l·ª≠a d·∫´n n·ªï",
                homingRicochet: "T√™n L·ª≠a X√≠ch",
                homingRicochetDesc: "T√™n l·ª≠a nh·∫£y m·ª•c ti√™u",
                bulletRicochet: "Ph√°o ƒê√†i",
                bulletRicochetDesc: "Ph√°o b√™n n·∫£y ƒë·∫°n",
                bulletPierce: "S√∫ng ƒê·∫°i B√°c",
                bulletPierceDesc: "D√≤ng xuy√™n ph√° h·ªßy",
                explosionElectric: "B√£o Plasma",
                explosionElectricDesc: "N·ªï ƒëi·ªán",
                laserPierce: "Tia Xuy√™n",
                laserPierceDesc: "Laser kh√¥ng g√¨ ch·∫∑n",
                laserRicochet: "L∆∞·ªõi Laser",
                laserRicochetDesc: "M·∫°ng laser l·ªìng gh√©p",
                laserElectric: "Ph√°o Tesla",
                laserElectricDesc: "Xung laser ƒëi·ªán",
                damage: "S√°t Th∆∞∆°ng",
                attackSpeed: "T·ªëc ƒê·ªô",
                maxHearts: "Tim T·ªëi ƒêa",
                critRate: "T·ª∑ L·ªá Ch√≠ M·∫°ng",
                tier1: "C·∫§P 1",
                tier2: "C·∫§P 2",
                tier3: "C·∫§P 3 - H·ª¢P NH·∫§T",
                cost: "Gi√°:",
                stage: "M√†n",
                difficulty: "ƒê·ªô kh√≥:",
                rewards: "Ph·∫ßn th∆∞·ªüng:",
                boss: "Boss:",
                yes: "C√≥",
                no: "Kh√¥ng"
            }
        };

        let currentLang = 'en';

        function updateLanguage(lang) {
            currentLang = lang;
            const t = translations[lang];
            
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('gameSubtitle').textContent = t.gameSubtitle;
            document.getElementById('btnEndless').textContent = t.btnEndless;
            document.getElementById('btnStage').textContent = t.btnStage;
            document.getElementById('btnUpgrades').textContent = t.btnUpgrades;
            document.getElementById('btnTree').textContent = t.btnTree;
            document.getElementById('levelUpTitle').textContent = t.levelUpTitle;
            document.getElementById('chooseUpgrade').textContent = t.chooseUpgrade;
            document.getElementById('gameOverTitle').textContent = t.gameOverTitle;
            document.getElementById('scoreText').innerHTML = t.scoreText + ' <span id="finalScore">0</span>';
            document.getElementById('earnedText').innerHTML = t.earnedText + ' <span id="earnedCurrency">0</span> üíé';
            document.getElementById('btnMainMenu').textContent = t.btnMainMenu;
            document.getElementById('btnRestart').textContent = t.btnRestart;
            document.getElementById('upgradesTitle').textContent = t.upgradesTitle;
            document.getElementById('treeTitle').textContent = t.treeTitle;
            document.getElementById('btnBack').textContent = t.btnBack;
            document.getElementById('btnBackStage').textContent = t.btnBackStage;
            document.getElementById('btnBackTree').textContent = t.btnBackTree;
            document.getElementById('stageSelectTitle').textContent = t.stageSelectTitle;
            
            updateLevelText();
        }

        document.getElementById('langSelect').addEventListener('change', (e) => {
            updateLanguage(e.target.value);
        });

        // Game Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game State
        let gameState = {
            mode: 'endless',
            running: false,
            paused: false,
            score: 0,
            level: 1,
            xp: 0,
            xpToLevel: 100,
            currency: parseInt(localStorage.getItem('currency')) || 0,
            startTime: 0,
            elapsedTime: 0,
            lastBossTime: 0,
            currentStage: null,
            permanentUpgrades: JSON.parse(localStorage.getItem('upgrades')) || {
                damage: 0,
                attackSpeed: 0,
                maxHearts: 0,
                critRate: 0
            },
            upgradeTree: JSON.parse(localStorage.getItem('upgradeTree')) || {}
        };

        // Upgrade Tree Configuration
        const UPGRADE_TREE_CONFIG = {
            tier1: [
                { id: 'damage1', name: 'Damage +10%', cost: 100, effect: { damage: 0.1 } },
                { id: 'speed1', name: 'Speed +15%', cost: 100, effect: { attackSpeed: 0.15 } },
                { id: 'health1', name: 'Health +1', cost: 150, effect: { maxHearts: 1 } }
            ],
            tier2: [
                { id: 'damage2', name: 'Damage +20%', cost: 200, requires: ['damage1'], effect: { damage: 0.2 } },
                { id: 'crit1', name: 'Crit +10%', cost: 250, requires: ['speed1'], effect: { critRate: 0.1 } },
                { id: 'health2', name: 'Health +2', cost: 300, requires: ['health1'], effect: { maxHearts: 2 } }
            ],
            tier3: [
                { id: 'master', name: 'Master Gunner', cost: 500, requires: ['damage2', 'crit1'], effect: { damage: 0.5, critRate: 0.2 } }
            ]
        };

        // Player
        let player = {
            x: 450,
            y: 600,
            width: 40,
            height: 40,
            speed: 6,
            damage: 10,
            attackSpeed: 10,
            critChance: 0.05,
            hearts: 3,
            maxHearts: 3,
            lastShot: 0,
            skills: {},
            bulletCount: 1,
            piercing: false,
            piercingUnlimited: false,
            explosive: false,
            explosionRadius: 60,
            homing: false,
            homingCount: 1,
            ricochet: false,
            ricochetCount: 0,
            electricTimer: 0,
            electricInterval: 7000,
            laserDrops: [],
            sideCannons: false
        };

        // Arrays
        let bullets = [];
        let homingMissiles = [];
        let asteroids = [];
        let particles = [];
        let damageTexts = [];
        let bosses = [];
        let electricBeams = [];
        let lasers = [];

        // Input
        let keys = {};

        // Skills Database with detailed specifications
        const skillsDatabase = {
            homing: {
                name: 'homing',
                icon: 'üöÄ',
                maxTier: 2,
                tier1: {
                    homingCount: 1,
                    homingDamage: 1.5
                },
                tier2: {
                    homingCount: 3,
                    homingDamage: 1.5
                }
            },
            bulletCount: {
                name: 'bulletCount',
                icon: 'üí´',
                maxTier: 2,
                tier1: {
                    bulletCount: 2,
                    bulletDamage: 0.75
                },
                tier2: {
                    bulletCount: 3,
                    bulletDamage: 1.0
                }
            },
            explosion: {
                name: 'explosion',
                icon: 'üí•',
                maxTier: 2,
                tier1: {
                    explosive: true,
                    explosionDamage: 0.5,
                    impactDamage: 1.25
                },
                tier2: {
                    explosionRadius: 100,
                    explosionDamage: 1.0,
                    impactDamage: 1.5
                }
            },
            electric: {
                name: 'electric',
                icon: '‚ö°',
                maxTier: 2,
                tier1: {
                    electricInterval: 7000,
                    electricDamage: 2.0,
                    chainDamage: 1.0,
                    maxChain: 5
                },
                tier2: {
                    electricInterval: 5000,
                    electricDamage: 3.0,
                    chainDamage: 1.5,
                    maxChain: 8
                }
            },
            laserDrop: {
                name: 'laserDrop',
                icon: 'üî¥',
                maxTier: 2,
                tier1: {
                    laserDropCount: 1,
                    laserDuration: 10000,
                    laserInterval: 15000
                },
                tier2: {
                    laserDropCount: 2,
                    laserDuration: 15000,
                    laserInterval: 15000,
                    laserDamage: 1.5
                }
            },
            ricochet: {
                name: 'ricochet',
                icon: 'üîÑ',
                maxTier: 2,
                tier1: {
                    ricochetCount: 1,
                    ricochetDamages: [1.5, 1.0]
                },
                tier2: {
                    ricochetCount: 2,
                    ricochetDamages: [2.0, 1.5, 1.0]
                }
            },
            pierce: {
                name: 'pierce',
                icon: 'üéØ',
                maxTier: 2,
                tier1: {
                    pierceCount: 3
                },
                tier2: {
                    piercingUnlimited: true
                }
            }
        };

        // Tier 3 Fusion Skills
        const fusionSkills = {
            homingExplosion: {
                requires: ['homing', 'explosion'],
                name: 'homingExplosion',
                icon: 'üåü',
                homingCount: 4,
                homingDamage: 1.5,
                explosive: true,
                explosionDamage: 1.0
            },
            homingRicochet: {
                requires: ['homing', 'ricochet'],
                name: 'homingRicochet',
                icon: 'üéÜ',
                homingCount: 3,
                homingJumps: 3
            },
            bulletRicochet: {
                requires: ['bulletCount', 'ricochet'],
                name: 'bulletRicochet',
                icon: 'üî´',
                sideCannons: true,
                ricochetCount: 3
            },
            bulletPierce: {
                requires: ['bulletCount', 'pierce'],
                name: 'bulletPierce',
                icon: '‚öîÔ∏è',
                bulletCount: 3,
                pierceDamages: [5.0, 4.0, 3.0, 2.0]
            },
            explosionElectric: {
                requires: ['explosion', 'electric'],
                name: 'explosionElectric',
                icon: '‚ö°',
                electricBeam: true,
                chainExplosion: true,
                explosionDamage: 2.0,
                electricDamage: 1.25
            },
            laserPierce: {
                requires: ['laserDrop', 'pierce'],
                name: 'laserPierce',
                icon: 'üî¥',
                laserPiercing: true,
                laserDamage: 2.0,
                laserInterval: 12000
            },
            laserRicochet: {
                requires: ['laserDrop', 'ricochet'],
                name: 'laserRicochet',
                icon: 'üì°',
                laserGrid: true,
                laserDuration: 20000
            },
            laserElectric: {
                requires: ['laserDrop', 'electric'],
                name: 'laserElectric',
                icon: '‚ö°',
                laserElectric: true,
                mainShipElectric: { first: 2.0, chain: 1.25 },
                laserDropElectric: { first: 5.0, chain: 1.5 }
            }
        };

        // Initialize
        function init() {
            applyPermanentUpgrades();
            applyTreeUpgrades();
            updateCurrency();
            updateHearts();
            updateLevelText();
            renderStageList();
        }

        function applyPermanentUpgrades() {
            const upgrades = gameState.permanentUpgrades;
            player.damage = 10 + upgrades.damage * 2;
            player.attackSpeed = 10 + upgrades.attackSpeed * 1;
            player.maxHearts = 3 + upgrades.maxHearts;
            player.hearts = player.maxHearts;
            player.critChance = 0.05 + upgrades.critRate * 0.02;
        }

        function applyTreeUpgrades() {
            let damageBonus = 0;
            let speedBonus = 0;
            let heartBonus = 0;
            let critBonus = 0;

            for (const nodeId in gameState.upgradeTree) {
                const node = findTreeNode(nodeId);
                if (node && node.effect) {
                    if (node.effect.damage) damageBonus += node.effect.damage;
                    if (node.effect.attackSpeed) speedBonus += node.effect.attackSpeed;
                    if (node.effect.maxHearts) heartBonus += node.effect.maxHearts;
                    if (node.effect.critRate) critBonus += node.effect.critRate;
                }
            }

            player.damage = Math.floor(player.damage * (1 + damageBonus));
            player.attackSpeed = Math.floor(player.attackSpeed * (1 + speedBonus));
            player.maxHearts += heartBonus;
            player.hearts = player.maxHearts;
            player.critChance += critBonus;
        }

        function findTreeNode(id) {
            for (const tier in UPGRADE_TREE_CONFIG) {
                const node = UPGRADE_TREE_CONFIG[tier].find(n => n.id === id);
                if (node) return node;
            }
            return null;
        }

        function startGame(mode, stageNum = null) {
            gameState.mode = mode;
            gameState.currentStage = stageNum;
            gameState.running = true;
            gameState.paused = false;
            gameState.score = 0;
            gameState.level = 1;
            gameState.xp = 0;
            gameState.xpToLevel = 100;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.lastBossTime = 0;

            player.x = 450;
            player.y = 600;
            player.skills = {};
            player.bulletCount = 1;
            player.piercing = false;
            player.piercingUnlimited = false;
            player.explosive = false;
            player.explosionRadius = 60;
            player.homing = false;
            player.homingCount = 1;
            player.ricochet = false;
            player.ricochetCount = 0;
            player.electricTimer = 0;
            player.electricInterval = 7000;
            player.laserDrops = [];
            player.sideCannons = false;
            
            applyPermanentUpgrades();
            applyTreeUpgrades();

            bullets = [];
            homingMissiles = [];
            asteroids = [];
            particles = [];
            damageTexts = [];
            bosses = [];
            electricBeams = [];
            lasers = [];

            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('stageSelect').classList.remove('active');
            updateHearts();
            updateLevelText();
            updateXP();
            updateTimer();

            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOverMenu').classList.remove('active');
            startGame(gameState.mode, gameState.currentStage);
        }

        function showMainMenu() {
            document.getElementById('gameOverMenu').classList.remove('active');
            document.getElementById('mainMenu').classList.add('active');
            gameState.running = false;
        }

        function showStageSelect() {
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('stageSelect').classList.add('active');
            renderStageList();
        }

        function hideStageSelect() {
            document.getElementById('stageSelect').classList.remove('active');
            document.getElementById('mainMenu').classList.add('active');
        }

        function renderStageList() {
            const t = translations[currentLang];
            const stageList = document.getElementById('stageList');
            stageList.innerHTML = '';

            for (const [stageNum, config] of Object.entries(STAGE_CONFIG)) {
                const div = document.createElement('div');
                div.className = 'stage-card';
                div.onclick = () => startGame('stage', parseInt(stageNum));
                
                div.innerHTML = `
                    <div class="stage-number">${t.stage} ${stageNum}</div>
                    <div style="color: #fff; margin: 10px 0;">${config.name}</div>
                    <div class="stage-difficulty">${t.difficulty} ${config.difficulty}</div>
                    <div style="color: #4facfe; font-size: 14px; margin-top: 5px;">
                        ${t.rewards} ${config.rewards} üíé
                    </div>
                    <div style="color: #ff4757; font-size: 14px; margin-top: 5px;">
                        ${t.boss} ${config.bossCount > 0 ? t.yes : t.no}
                    </div>
                `;
                stageList.appendChild(div);
            }
        }

        function showUpgrades() {
            const t = translations[currentLang];
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('upgradesMenu').classList.add('active');
            
            const upgradeStats = document.getElementById('upgradeStats');
            upgradeStats.innerHTML = '';

            const stats = [
                { name: 'damage', label: t.damage, cost: 50 },
                { name: 'attackSpeed', label: t.attackSpeed, cost: 50 },
                { name: 'maxHearts', label: t.maxHearts, cost: 100 },
                { name: 'critRate', label: t.critRate, cost: 75 }
            ];

            stats.forEach(stat => {
                const value = gameState.permanentUpgrades[stat.name] || 0;
                const canAfford = gameState.currency >= stat.cost;
                
                const div = document.createElement('div');
                div.className = 'stat-item';
                div.innerHTML = `
                    <div class="stat-name">${stat.label}</div>
                    <div class="stat-value">${value}</div>
                    <button class="btn btn-small" 
                            onclick="buyUpgrade('${stat.name}', ${stat.cost})"
                            ${!canAfford ? 'disabled style="opacity:0.5"' : ''}>
                        ${t.cost} ${stat.cost} üíé
                    </button>
                `;
                upgradeStats.appendChild(div);
            });

            document.getElementById('upgradeCurrency').textContent = `üíé ${gameState.currency}`;
        }

        function hideUpgrades() {
            document.getElementById('upgradesMenu').classList.remove('active');
            document.getElementById('mainMenu').classList.add('active');
        }

        function buyUpgrade(stat, cost) {
            if (gameState.currency >= cost) {
                gameState.currency -= cost;
                gameState.permanentUpgrades[stat]++;
                
                localStorage.setItem('currency', gameState.currency);
                localStorage.setItem('upgrades', JSON.stringify(gameState.permanentUpgrades));
                
                updateCurrency();
                showUpgrades();
            }
        }

        function showUpgradeTree() {
            const t = translations[currentLang];
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('upgradeTreeMenu').classList.add('active');
            
            const container = document.getElementById('upgradeTreeContainer');
            container.innerHTML = '';

            for (const [tierName, nodes] of Object.entries(UPGRADE_TREE_CONFIG)) {
                const row = document.createElement('div');
                row.className = 'tree-row';

                nodes.forEach(node => {
                    const isPurchased = gameState.upgradeTree[node.id];
                    const canAfford = gameState.currency >= node.cost;
                    const meetsRequirements = !node.requires || node.requires.every(req => gameState.upgradeTree[req]);
                    const isLocked = !meetsRequirements || isPurchased;

                    const div = document.createElement('div');
                    div.className = `tree-node ${isPurchased ? 'purchased' : ''} ${!meetsRequirements ? 'locked' : ''}`;
                    
                    if (!isPurchased && meetsRequirements && canAfford) {
                        div.onclick = () => buyTreeNode(node);
                    }

                    div.innerHTML = `
                        <div style="font-weight: bold; color: #4facfe; margin-bottom: 5px;">${node.name}</div>
                        <div style="color: #ffd700; font-size: 14px;">${t.cost} ${node.cost} üíé</div>
                        ${isPurchased ? '<div style="color: #2ecc71; margin-top: 5px;">‚úì Owned</div>' : ''}
                    `;
                    row.appendChild(div);
                });

                container.appendChild(row);
            }

            document.getElementById('treeCurrency').textContent = `üíé ${gameState.currency}`;
        }

        function hideUpgradeTree() {
            document.getElementById('upgradeTreeMenu').classList.remove('active');
            document.getElementById('mainMenu').classList.add('active');
        }

        function buyTreeNode(node) {
            if (gameState.currency >= node.cost) {
                gameState.currency -= node.cost;
                gameState.upgradeTree[node.id] = true;
                
                localStorage.setItem('currency', gameState.currency);
                localStorage.setItem('upgradeTree', JSON.stringify(gameState.upgradeTree));
                
                updateCurrency();
                showUpgradeTree();
            }
        }

        function updateCurrency() {
            document.getElementById('currencyDisplay').textContent = `üíé ${gameState.currency}`;
        }

        function updateHearts() {
            const heartsDisplay = document.getElementById('heartsDisplay');
            heartsDisplay.innerHTML = '';
            for (let i = 0; i < player.hearts; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heartsDisplay.appendChild(heart);
            }
        }

        function updateLevelText() {
            const t = translations[currentLang];
            document.getElementById('levelText').textContent = `${t.level} ${gameState.level}`;
        }

        function updateTimer() {
            if (!gameState.running || gameState.paused) return;
            
            gameState.elapsedTime = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = Math.floor(gameState.elapsedTime / 60);
            const seconds = gameState.elapsedTime % 60;
            
            const t = translations[currentLang];
            document.getElementById('timerDisplay').textContent = 
                `${t.time} ${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Boss spawn in endless mode
            if (gameState.mode === 'endless' && gameState.elapsedTime - gameState.lastBossTime >= 300) {
                spawnBoss();
                gameState.lastBossTime = gameState.elapsedTime;
            }

            // Stage completion check
            if (gameState.mode === 'stage' && gameState.currentStage) {
                const config = STAGE_CONFIG[gameState.currentStage];
                if (gameState.elapsedTime >= config.duration) {
                    completeStage();
                    return;
                }

                // Boss spawns in stage mode
                if (config.bossSpawnTimes) {
                    config.bossSpawnTimes.forEach(time => {
                        if (gameState.elapsedTime === time) {
                            spawnBoss();
                        }
                        if (gameState.elapsedTime === time - 3) {
                            showBossWarning();
                        }
                    });
                }
            }
        }

        function showBossWarning() {
            const warning = document.getElementById('bossWarning');
            warning.style.display = 'block';
            setTimeout(() => {
                warning.style.display = 'none';
            }, 3000);
        }

        function completeStage() {
            gameState.running = false;
            const config = STAGE_CONFIG[gameState.currentStage];
            const earned = config.rewards + Math.floor(gameState.score / 10);
            gameState.currency += earned;
            
            localStorage.setItem('currency', gameState.currency);
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('earnedCurrency').textContent = earned;
            document.getElementById('gameOverMenu').classList.add('active');
            
            updateCurrency();
        }

        function updateXP() {
            const percent = (gameState.xp / gameState.xpToLevel) * 100;
            document.getElementById('xpFill').style.width = `${percent}%`;
        }

        function gainXP(amount) {
            gameState.xp += amount;
            if (gameState.xp >= gameState.xpToLevel) {
                levelUp();
            }
            updateXP();
        }

        function levelUp() {
            gameState.level++;
            gameState.xp = 0;
            gameState.xpToLevel = Math.floor(gameState.xpToLevel * 1.5);
            updateLevelText();
            updateXP();
            
            gameState.paused = true;
            showLevelUpMenu();
        }

        function showLevelUpMenu() {
            const t = translations[currentLang];
            const cards = getUpgradeOptions();
            const upgradeCards = document.getElementById('upgradeCards');
            upgradeCards.innerHTML = '';

            cards.forEach(card => {
                const div = document.createElement('div');
                div.className = card.tier === 3 ? 'card fusion' : 'card';
                div.onclick = () => selectUpgrade(card);
                
                let tierText = card.tier === 3 ? t.tier3 : (card.tier === 2 ? t.tier2 : t.tier1);

                div.innerHTML = `
                    <div class="card-icon">${card.icon}</div>
                    <div class="card-title">${t[card.name] || card.name}</div>
                    <div class="card-desc">${t[card.name + 'Desc'] || card.desc}</div>
                    <div class="card-tier">${tierText}</div>
                `;
                upgradeCards.appendChild(div);
            });

            document.getElementById('levelUpMenu').classList.add('active');
        }

        function getUpgradeOptions() {
            const available = [];
            
            // Check for Tier 3 Fusions
            for (const [fusionName, fusion] of Object.entries(fusionSkills)) {
                const hasRequirements = fusion.requires.every(req => 
                    player.skills[req] && player.skills[req] === 2
                );
                
                if (hasRequirements && !player.skills[fusionName]) {
                    available.push({
                        name: fusionName,
                        tier: 3,
                        icon: fusion.icon,
                        desc: 'Fusion skill',
                        data: fusion
                    });
                }
            }

            // Check for Tier 1 and Tier 2 skills
            for (const [skillName, skill] of Object.entries(skillsDatabase)) {
                const currentTier = player.skills[skillName] || 0;
                
                if (currentTier < skill.maxTier) {
                    available.push({
                        name: skillName,
                        tier: currentTier + 1,
                        icon: skill.icon,
                        desc: `Upgrade ${skillName}`,
                        data: skill
                    });
                }
            }

            // Return 3 random options
            const shuffled = available.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, Math.min(3, available.length));
        }

        function selectUpgrade(card) {
            if (card.tier === 3) {
                player.skills[card.name] = 3;
                applySkillEffects(card.data);
            } else {
                player.skills[card.name] = card.tier;
                const tierData = card.tier === 1 ? card.data.tier1 : card.data.tier2;
                applySkillEffects(tierData);
            }

            document.getElementById('levelUpMenu').classList.remove('active');
            gameState.paused = false;
        }

        function applySkillEffects(effects) {
            if (effects.homingCount !== undefined) player.homingCount = effects.homingCount;
            if (effects.homingDamage !== undefined) player.homingDamage = effects.homingDamage;
            if (effects.bulletCount !== undefined) player.bulletCount = effects.bulletCount;
            if (effects.bulletDamage !== undefined) player.bulletDamage = effects.bulletDamage;
            if (effects.explosive) player.explosive = true;
            if (effects.explosionRadius !== undefined) player.explosionRadius = effects.explosionRadius;
            if (effects.explosionDamage !== undefined) player.explosionDamage = effects.explosionDamage;
            if (effects.impactDamage !== undefined) player.impactDamage = effects.impactDamage;
            if (effects.electricInterval !== undefined) player.electricInterval = effects.electricInterval;
            if (effects.electricDamage !== undefined) player.electricDamage = effects.electricDamage;
            if (effects.chainDamage !== undefined) player.chainDamage = effects.chainDamage;
            if (effects.maxChain !== undefined) player.maxChain = effects.maxChain;
            if (effects.ricochetCount !== undefined) player.ricochetCount = effects.ricochetCount;
            if (effects.ricochetDamages !== undefined) player.ricochetDamages = effects.ricochetDamages;
            if (effects.pierceCount !== undefined) player.pierceCount = effects.pierceCount;
            if (effects.piercingUnlimited) player.piercingUnlimited = true;
            if (effects.sideCannons) player.sideCannons = true;
            if (effects.homingJumps !== undefined) player.homingJumps = effects.homingJumps;
            if (effects.pierceDamages !== undefined) player.pierceDamages = effects.pierceDamages;
            if (effects.electricBeam) player.electricBeam = true;
            if (effects.chainExplosion) player.chainExplosion = true;
            if (effects.laserPiercing) player.laserPiercing = true;
            if (effects.laserGrid) player.laserGrid = true;
            if (effects.laserElectric) player.laserElectric = true;
            if (effects.mainShipElectric) player.mainShipElectric = effects.mainShipElectric;
            if (effects.laserDropElectric) player.laserDropElectric = effects.laserDropElectric;
            
            if (effects.laserDropCount !== undefined) {
                player.laserDrops = [];
                for (let i = 0; i < effects.laserDropCount; i++) {
                    const height = i === 0 ? canvas.height / 3 : (canvas.height / 3) * 2;
                    player.laserDrops.push({
                        x: i === 0 ? 50 : canvas.width - 50,
                        y: height,
                        lastFire: 0,
                        interval: effects.laserInterval || 15000,
                        duration: effects.laserDuration || 10000,
                        active: false,
                        endTime: 0
                    });
                }
            }
        }

        // Game Loop
        function gameLoop() {
            if (!gameState.running) return;

            if (!gameState.paused) {
                update();
                updateTimer();
                render();
            } else {
                render();
            }

            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Player movement
            if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
            if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
            if (keys['ArrowDown'] || keys['s']) player.y += player.speed;

            player.x = Math.max(30, Math.min(870, player.x));
            player.y = Math.max(30, Math.min(670, player.y));

            // Auto shoot
            const now = Date.now();
            const shootInterval = 1000 / player.attackSpeed;
            if (now - player.lastShot > shootInterval) {
                shoot();
                player.lastShot = now;
            }

            // Homing missiles
            if (player.homingCount > 0 && now - (player.lastHomingShot || 0) > 2000) {
                shootHoming();
                player.lastHomingShot = now;
            }

            // Electric attack
            if (player.electricInterval && now - player.electricTimer > player.electricInterval) {
                fireElectric();
                player.electricTimer = now;
            }

            // Laser drops
            player.laserDrops.forEach(drop => {
                if (!drop.active && now - drop.lastFire > drop.interval) {
                    drop.active = true;
                    drop.endTime = now + drop.duration;
                    drop.lastFire = now;
                }
                if (drop.active && now > drop.endTime) {
                    drop.active = false;
                }
            });

            // Update bullets
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                if (bullet.y < -10 || bullet.y > 710 || bullet.x < -10 || bullet.x > 910) {
                    bullets.splice(index, 1);
                }
            });

            // Update homing missiles
            homingMissiles.forEach((missile, index) => {
                const closest = findClosestAsteroid(missile);
                if (closest && (!missile.hitTargets || !missile.hitTargets.includes(closest.id))) {
                    const dx = closest.x - missile.x;
                    const dy = closest.y - missile.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    missile.vx += (dx / dist) * 0.5;
                    missile.vy += (dy / dist) * 0.5;
                }

                missile.x += missile.vx;
                missile.y += missile.vy;

                if (missile.y < -10 || missile.y > 710 || missile.x < -10 || missile.x > 910) {
                    homingMissiles.splice(index, 1);
                }
            });

            // Spawn asteroids
            const spawnRate = gameState.mode === 'stage' && gameState.currentStage ? 
                STAGE_CONFIG[gameState.currentStage].spawnRate : 0.02;
            
            if (Math.random() < spawnRate) {
                spawnAsteroid();
            }

            // Update asteroids
            asteroids.forEach((asteroid, index) => {
                asteroid.y += asteroid.vy;
                asteroid.x += asteroid.vx;
                asteroid.rotation += asteroid.rotationSpeed;

                if (asteroid.x <= asteroid.size / 2 || asteroid.x >= 900 - asteroid.size / 2) {
                    asteroid.vx *= -1;
                }

                if (checkCollision(player, asteroid)) {
                    player.hearts--;
                    updateHearts();
                    asteroids.splice(index, 1);
                    createParticles(asteroid.x, asteroid.y, '#ff4757', 20);

                    if (player.hearts <= 0) {
                        gameOver();
                    }
                }

                if (asteroid.y > 750) {
                    asteroids.splice(index, 1);
                }
            });

            // Update bosses
            bosses.forEach((boss, index) => {
                boss.x += boss.vx;
                if (boss.x <= boss.size || boss.x >= 900 - boss.size) {
                    boss.vx *= -1;
                }

                if (checkCollision(player, boss)) {
                    player.hearts--;
                    updateHearts();
                    if (player.hearts <= 0) {
                        gameOver();
                    }
                }
            });

            // Bullet-Asteroid collision
            bullets.forEach((bullet, bIndex) => {
                let hitCount = 0;
                asteroids.forEach((asteroid, eIndex) => {
                    if (checkCollision(bullet, asteroid)) {
                        const isCrit = Math.random() < player.critChance;
                        let damage = player.damage;
                        
                        if (player.pierceDamages && bullet.pierceHits !== undefined) {
                            const idx = Math.min(bullet.pierceHits, player.pierceDamages.length - 1);
                            damage = player.damage * player.pierceDamages[idx];
                        } else if (player.impactDamage) {
                            damage *= player.impactDamage;
                        } else if (player.bulletDamage) {
                            damage *= player.bulletDamage;
                        }
                        
                        if (isCrit) damage *= 2;
                        
                        asteroid.hp -= damage;
                        createDamageText(asteroid.x, asteroid.y, Math.floor(damage), isCrit ? 'crit' : 'normal');
                        
                        if (asteroid.hp <= 0) {
                            handleAsteroidDeath(asteroid, eIndex);
                            gainXP(10);
                            gameState.score += 10;
                        }

                        if (player.explosive) {
                            explode(bullet.x, bullet.y);
                        }

                        hitCount++;
                        bullet.pierceHits = (bullet.pierceHits || 0) + 1;

                        if (!player.piercingUnlimited && (!player.pierceCount || hitCount >= player.pierceCount)) {
                            bullets.splice(bIndex, 1);
                            return;
                        }
                    }
                });
            });

            // Homing missile collisions
            homingMissiles.forEach((missile, mIndex) => {
                asteroids.forEach((asteroid, eIndex) => {
                    if (checkCollision(missile, asteroid)) {
                        const damage = player.damage * (player.homingDamage || 1.5);
                        asteroid.hp -= damage;
                        createDamageText(asteroid.x, asteroid.y, Math.floor(damage), 'homing');
                        
                        if (asteroid.hp <= 0) {
                            handleAsteroidDeath(asteroid, eIndex);
                            gainXP(10);
                            gameState.score += 10;
                        }

                        if (missile.explosive) {
                            explode(missile.x, missile.y);
                        }

                        if (player.homingJumps && missile.jumps < player.homingJumps) {
                            missile.jumps++;
                            missile.hitTargets = missile.hitTargets || [];
                            missile.hitTargets.push(asteroid.id);
                        } else {
                            homingMissiles.splice(mIndex, 1);
                        }
                    }
                });
            });

            // Laser collisions
            player.laserDrops.forEach(drop => {
                if (!drop.active) return;
                
                asteroids.forEach((asteroid, eIndex) => {
                    const inLaserPath = Math.abs(asteroid.x - drop.x) < 10;
                    if (inLaserPath && !asteroid.laserHit) {
                        const damage = player.damage * (player.laserDamage || 1.5);
                        asteroid.hp -= damage;
                        asteroid.laserHit = true;
                        createDamageText(asteroid.x, asteroid.y, Math.floor(damage), 'laser');
                        
                        if (asteroid.hp <= 0) {
                            handleAsteroidDeath(asteroid, eIndex);
                            gainXP(10);
                            gameState.score += 10;
                        }

                        if (!player.laserPiercing) {
                            drop.active = false;
                        }

                        setTimeout(() => { asteroid.laserHit = false; }, 100);
                    }
                });
            });

            // Update particles
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Update damage texts
            damageTexts.forEach((text, index) => {
                text.y -= 2;
                text.life--;
                if (text.life <= 0) {
                    damageTexts.splice(index, 1);
                }
            });
        }

        function shoot() {
            const spreadAngle = 0.3;
            const count = player.bulletCount || 1;
            const startAngle = -(count - 1) * spreadAngle / 2;

            for (let i = 0; i < count; i++) {
                const angle = startAngle + i * spreadAngle;
                bullets.push({
                    x: player.x,
                    y: player.y - 20,
                    vx: Math.sin(angle) * 3,
                    vy: -12,
                    width: 8,
                    height: 14,
                    pierceHits: 0
                });
            }

            if (player.sideCannons) {
                [-40, 40].forEach(offset => {
                    bullets.push({
                        x: player.x + offset,
                        y: player.y,
                        vx: 0,
                        vy: -10,
                        width: 8,
                        height: 14,
                        pierceHits: 0,
                        ricochet: true
                    });
                });
            }
        }

        function shootHoming() {
            for (let i = 0; i < player.homingCount; i++) {
                homingMissiles.push({
                    x: player.x + (i - player.homingCount / 2) * 20,
                    y: player.y - 30,
                    vx: 0,
                    vy: -8,
                    width: 10,
                    height: 20,
                    explosive: player.explosive || false,
                    jumps: 0,
                    hitTargets: []
                });
            }
        }

        function fireElectric() {
            const closest = findClosestAsteroid(player);
            if (!closest) return;

            const beam = {
                x: player.x,
                y: player.y,
                targets: [closest],
                life: 30,
                damage: player.damage * (player.electricDamage || 2.0)
            };

            let current = closest;
            const maxChain = player.maxChain || 5;
            
            for (let i = 1; i < maxChain; i++) {
                const next = findClosestAsteroid(current, beam.targets);
                if (!next) break;
                beam.targets.push(next);
                current = next;
            }

            beam.targets.forEach((target, idx) => {
                const dmg = idx === 0 ? beam.damage : beam.damage * (player.chainDamage || 1.0);
                target.hp -= dmg;
                createDamageText(target.x, target.y, Math.floor(dmg), 'electric');
                
                if (target.hp <= 0) {
                    const index = asteroids.indexOf(target);
                    if (index >= 0) {
                        handleAsteroidDeath(target, index);
                        gainXP(10);
                        gameState.score += 10;
                    }
                }
            });

            electricBeams.push(beam);
        }

        function spawnAsteroid() {
            const sizeTypes = ['gigantic', 'large', 'medium', 'small'];
            const sizeType = sizeTypes[Math.floor(Math.random() * Math.min(2, sizeTypes.length))];
            
            const sizeMap = {
                gigantic: { size: 120, hp: 200, speed: 0.5 },
                large: { size: 80, hp: 100, speed: 1 },
                medium: { size: 50, hp: 50, speed: 1.5 },
                small: { size: 30, hp: 25, speed: 2 }
            };

            const data = sizeMap[sizeType];
            const hpMultiplier = gameState.mode === 'stage' && gameState.currentStage ? 
                STAGE_CONFIG[gameState.currentStage].asteroidHPMultiplier : 1.0;

            asteroids.push({
                id: Date.now() + Math.random(),
                x: Math.random() * (900 - data.size) + data.size / 2,
                y: -data.size,
                size: data.size,
                hp: data.hp * hpMultiplier,
                maxHp: data.hp * hpMultiplier,
                vx: (Math.random() - 0.5) * 2,
                vy: data.speed,
                sizeType: sizeType,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                vertices: generateAsteroidShape(data.size)
            });
        }

        function generateAsteroidShape(size) {
            const vertices = [];
            const count = 8 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const radius = size / 2 * (0.8 + Math.random() * 0.4);
                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }
            
            return vertices;
        }

        function handleAsteroidDeath(asteroid, index) {
            createParticles(asteroid.x, asteroid.y, '#4facfe', 15);
            
            const splitMap = {
                gigantic: 'large',
                large: 'medium',
                medium: 'small',
                small: null
            };

            const nextSize = splitMap[asteroid.sizeType];
            if (nextSize) {
                splitAsteroid(asteroid, nextSize);
            }
            
            asteroids.splice(index, 1);
        }

        function splitAsteroid(asteroid, newSizeType) {
            const sizeMap = {
                large: { size: 80, hp: 100, speed: 1 },
                medium: { size: 50, hp: 50, speed: 1.5 },
                small: { size: 30, hp: 25, speed: 2 }
            };

            const data = sizeMap[newSizeType];
            const hpMultiplier = gameState.mode === 'stage' && gameState.currentStage ? 
                STAGE_CONFIG[gameState.currentStage].asteroidHPMultiplier : 1.0;

            for (let i = 0; i < 2; i++) {
                asteroids.push({
                    id: Date.now() + Math.random(),
                    x: asteroid.x + (i === 0 ? -30 : 30),
                    y: asteroid.y,
                    size: data.size,
                    hp: data.hp * hpMultiplier,
                    maxHp: data.hp * hpMultiplier,
                    vx: (i === 0 ? -2 : 2),
                    vy: data.speed,
                    sizeType: newSizeType,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    vertices: generateAsteroidShape(data.size)
                });
            }
        }

        function spawnBoss() {
            bosses.push({
                x: 450,
                y: 100,
                size: 100,
                hp: 5000,
                maxHp: 5000,
                vx: 2,
                vy: 0,
                phase: 1
            });
        }

        function explode(x, y) {
            const radius = player.explosionRadius || 60;
            asteroids.forEach((asteroid, index) => {
                const dist = Math.sqrt((asteroid.x - x) ** 2 + (asteroid.y - y) ** 2);
                if (dist < radius) {
                    const damage = player.damage * (player.explosionDamage || 0.5);
                    asteroid.hp -= damage;
                    createDamageText(asteroid.x, asteroid.y, Math.floor(damage), 'explosion');
                    if (asteroid.hp <= 0) {
                        handleAsteroidDeath(asteroid, index);
                        gainXP(10);
                        gameState.score += 10;
                    }
                }
            });
            createParticles(x, y, '#ff6348', 25);
        }

        function findClosestAsteroid(obj, exclude = []) {
            let closest = null;
            let minDist = Infinity;
            
            asteroids.forEach(asteroid => {
                if (exclude.includes(asteroid)) return;
                const dist = Math.sqrt((asteroid.x - obj.x) ** 2 + (asteroid.y - obj.y) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    closest = asteroid;
                }
            });
            
            return closest;
        }

        function checkCollision(obj1, obj2) {
            const r1 = obj1.width ? Math.max(obj1.width, obj1.height) / 2 : obj1.size / 2;
            const r2 = obj2.width ? Math.max(obj2.width, obj2.height) / 2 : obj2.size / 2;
            const dist = Math.sqrt((obj1.x - obj2.x) ** 2 + (obj1.y - obj2.y) ** 2);
            return dist < r1 + r2;
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 40,
                    color: color
                });
            }
        }

        function createDamageText(x, y, damage, type) {
            const colors = {
                normal: '#fff',
                crit: '#ff4757',
                electric: '#4facfe',
                explosion: '#ff6348',
                homing: '#9b59b6',
                laser: '#e74c3c'
            };

            damageTexts.push({
                x: x,
                y: y,
                damage: damage,
                life: 60,
                color: colors[type] || '#fff',
                isCrit: type === 'crit'
            });
        }

        function gameOver() {
            gameState.running = false;
            const baseEarned = Math.floor(gameState.score / 10);
            const timeBonus = gameState.mode === 'stage' && gameState.currentStage ? 
                STAGE_CONFIG[gameState.currentStage].rewards : 0;
            const earned = baseEarned + timeBonus;
            
            gameState.currency += earned;
            localStorage.setItem('currency', gameState.currency);
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('earnedCurrency').textContent = earned;
            document.getElementById('gameOverMenu').classList.add('active');
            
            updateCurrency();
        }

        // Render
        function render() {
            // Clear
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, 900, 700);

            // Stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137) % 900;
                const y = (i * 521 + Date.now() * 0.01) % 700;
                const size = (i % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }

            // Lasers
            player.laserDrops.forEach(drop => {
                if (drop.active) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 8;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#e74c3c';
                    ctx.beginPath();
                    ctx.moveTo(drop.x, 0);
                    ctx.lineTo(drop.x, 700);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Laser drop visual
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(drop.x, drop.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Electric beams
            electricBeams.forEach((beam, idx) => {
                ctx.strokeStyle = '#4facfe';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#4facfe';
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                beam.targets.forEach(target => {
                    ctx.lineTo(target.x, target.y);
                });
                ctx.stroke();
                ctx.shadowBlur = 0;

                beam.life--;
                if (beam.life <= 0) {
                    electricBeams.splice(idx, 1);
                }
            });

            // Player
            ctx.save();
            ctx.translate(player.x, player.y);
            
            ctx.fillStyle = '#4facfe';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#4facfe';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, 20);
            ctx.lineTo(0, 15);
            ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#00f2fe';
            ctx.fillRect(-25, 0, 50, 8);
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, -5, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Bullets
            bullets.forEach(bullet => {
                ctx.fillStyle = player.explosive ? '#ff6348' : '#ffd700';
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(bullet.x - 4, bullet.y - 7, 8, 14);
                ctx.shadowBlur = 0;
            });

            // Homing missiles
            homingMissiles.forEach(missile => {
                ctx.fillStyle = '#9b59b6';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#9b59b6';
                ctx.save();
                ctx.translate(missile.x, missile.y);
                const angle = Math.atan2(missile.vy, missile.vx) + Math.PI / 2;
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-5, 10);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            });

            // Asteroids
            asteroids.forEach(asteroid => {
                const hpPercent = asteroid.hp / asteroid.maxHp;
                
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);

                // Inner glow
                ctx.fillStyle = `hsla(${hpPercent * 120}, 80%, 60%, 0.3)`;
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                asteroid.vertices.forEach((v, i) => {
                    if (i === 0) ctx.moveTo(v.x, v.y);
                    else ctx.lineTo(v.x, v.y);
                });
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                // Main body
                ctx.fillStyle = `hsl(${hpPercent * 120}, 70%, 40%)`;
                ctx.fill();

                // Border
                const gradient = ctx.createLinearGradient(-asteroid.size/2, -asteroid.size/2, asteroid.size/2, asteroid.size/2);
                gradient.addColorStop(0, `hsl(${hpPercent * 120}, 90%, 60%)`);
                gradient.addColorStop(1, `hsl(${hpPercent * 120 + 30}, 90%, 70%)`);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = gradient;
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.restore();

                // HP text
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${asteroid.size * 0.35}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#000';
                ctx.fillText(Math.ceil(asteroid.hp), asteroid.x, asteroid.y);
                ctx.shadowBlur = 0;
            });

            // Bosses
            bosses.forEach(boss => {
                ctx.fillStyle = '#ff4757';
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ff4757';
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', boss.x, boss.y);

                // Boss HP bar
                const barWidth = 200;
                const hpPercent = boss.hp / boss.maxHp;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(boss.x - barWidth/2, boss.y + boss.size + 20, barWidth, 10);
                ctx.fillStyle = '#ff4757';
                ctx.fillRect(boss.x - barWidth/2, boss.y + boss.size + 20, barWidth * hpPercent, 10);
            });

            // Particles
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 40;
                ctx.fillRect(particle.x, particle.y, 5, 5);
                ctx.globalAlpha = 1;
            });

            // Damage texts
            damageTexts.forEach(text => {
                ctx.fillStyle = text.color;
                ctx.font = text.isCrit ? 'bold 28px Arial' : 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = text.life / 60;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#000';
                ctx.fillText(text.damage, text.x, text.y);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });
        }

        // Input
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Initialize
        init();
    </script>
</body>
</html>